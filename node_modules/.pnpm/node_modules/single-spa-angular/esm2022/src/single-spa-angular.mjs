import { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';
import { SingleSpaPlatformLocation } from './extra-providers';
const defaultOptions = {
    // Required options that will be set by the library consumer.
    NgZone: null,
    bootstrapFunction: null,
    template: null,
    // Optional options
    Router: undefined,
    domElementGetter: undefined, // only optional if you provide a domElementGetter as a custom prop
    updateFunction: () => Promise.resolve(),
    bootstrappedNgModuleRefOrAppRef: null,
};
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export function singleSpaAngular(userOptions) {
    if (NG_DEV_MODE && typeof userOptions !== 'object') {
        throw Error('single-spa-angular requires a configuration object');
    }
    const options = {
        ...defaultOptions,
        ...userOptions,
    };
    if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {
        throw Error('single-spa-angular must be passed an options.bootstrapFunction');
    }
    if (NG_DEV_MODE && typeof options.template !== 'string') {
        throw Error('single-spa-angular must be passed options.template string');
    }
    if (NG_DEV_MODE && !options.NgZone) {
        throw Error(`single-spa-angular must be passed the NgZone option`);
    }
    if (NG_DEV_MODE && options.Router && !options.NavigationStart) {
        // We call `console.warn` except of throwing `new Error()` since this will not
        // be a breaking change.
        console.warn(`single-spa-angular must be passed the NavigationStart option`);
    }
    return {
        bootstrap: bootstrap.bind(null, options),
        mount: mount.bind(null, options),
        unmount: unmount.bind(null, options),
        update: options.updateFunction,
    };
}
async function bootstrap(options) {
    // Angular provides an opportunity to develop `zone-less` application, where developers
    // have to trigger change detection manually.
    // See https://angular.io/guide/zone#noopzone
    if (options.NgZone === 'noop') {
        return;
    }
    // Note that we have to make it a noop function because it's a static property and not
    // an instance property. We're unable to configure it for multiple apps when dependencies
    // are shared and reference the same `NgZone` class. We can't determine where this function
    // is being executed or under which application, making it difficult to assert whether this
    // app is running under its zone.
    options.NgZone.assertInAngularZone = () => { };
    options.NgZone.assertNotInAngularZone = () => { };
    options.routingEventListener = () => {
        options.bootstrappedNgZone.run(() => {
            // See https://github.com/single-spa/single-spa-angular/issues/86
            // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work
            // unless we tell Zone that something happened
        });
    };
}
async function mount(options, props) {
    getContainerElementAndSetTemplate(options, props);
    const bootstrapPromise = options.bootstrapFunction(props);
    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {
        throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);
    }
    const ngModuleRefOrAppRef = await bootstrapPromise;
    if (NG_DEV_MODE) {
        if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {
            throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);
        }
    }
    const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);
    const ngZoneEnabled = options.NgZone !== 'noop';
    // The user has to provide `BrowserPlatformLocation` only if his application uses routing.
    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.
    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use
    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.
    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {
        throw new Error(`
      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?
    `);
    }
    const bootstrappedOptions = options;
    if (ngZoneEnabled) {
        const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);
        // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`
        // function was not called.
        if (singleSpaPlatformLocation !== null) {
            skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);
        }
        bootstrappedOptions.bootstrappedNgZone = ngZone;
        window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);
    }
    bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;
    return ngModuleRefOrAppRef;
}
function unmount(options) {
    return Promise.resolve().then(() => {
        if (options.routingEventListener) {
            window.removeEventListener('single-spa:routing-event', options.routingEventListener);
        }
        options.bootstrappedNgModuleRefOrAppRef.destroy();
        options.bootstrappedNgModuleRefOrAppRef = null;
    });
}
function skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {
    if (!options.NavigationStart) {
        // As discussed we don't do anything right now if the developer doesn't provide
        // `options.NavigationStart` since this might be a breaking change.
        return;
    }
    const router = ngModuleRefOrAppRef.injector.get(options.Router);
    const subscription = router.events.subscribe((event) => {
        if (event instanceof options.NavigationStart) {
            const currentNavigation = router.getCurrentNavigation();
            // This listener will be set up for each Angular application
            // that has routing capabilities.
            // We set `skipLocationChange` for each non-imperative navigation,
            // Angular router checks under the hood if it has to change
            // the browser URL or not.
            // If `skipLocationChange` is truthy then Angular router will not call
            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.
            if (currentNavigation.trigger !== 'imperative') {
                currentNavigation.extras.skipLocationChange = true;
                currentNavigation.extras.replaceUrl = false;
            }
        }
    });
    ngModuleRefOrAppRef.onDestroy(() => subscription.unsubscribe());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xlLXNwYS1hbmd1bGFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGlicy9zaW5nbGUtc3BhLWFuZ3VsYXIvc3JjL3NpbmdsZS1zcGEtYW5ndWxhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUVqRixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUc5RCxNQUFNLGNBQWMsR0FBRztJQUNyQiw2REFBNkQ7SUFDN0QsTUFBTSxFQUFFLElBQUs7SUFDYixpQkFBaUIsRUFBRSxJQUFLO0lBQ3hCLFFBQVEsRUFBRSxJQUFLO0lBQ2YsbUJBQW1CO0lBQ25CLE1BQU0sRUFBRSxTQUFTO0lBQ2pCLGdCQUFnQixFQUFFLFNBQVMsRUFBRSxtRUFBbUU7SUFDaEcsY0FBYyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7SUFDdkMsK0JBQStCLEVBQUUsSUFBSTtDQUN0QyxDQUFDO0FBTUYsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUVsRSxNQUFNLFVBQVUsZ0JBQWdCLENBQUksV0FBdUM7SUFDekUsSUFBSSxXQUFXLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFLENBQUM7UUFDbkQsTUFBTSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQsTUFBTSxPQUFPLEdBQTRCO1FBQ3ZDLEdBQUcsY0FBYztRQUNqQixHQUFHLFdBQVc7S0FDZixDQUFDO0lBRUYsSUFBSSxXQUFXLElBQUksT0FBTyxPQUFPLENBQUMsaUJBQWlCLEtBQUssVUFBVSxFQUFFLENBQUM7UUFDbkUsTUFBTSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztJQUNoRixDQUFDO0lBRUQsSUFBSSxXQUFXLElBQUksT0FBTyxPQUFPLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQ3hELE1BQU0sS0FBSyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVELElBQUksV0FBVyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ25DLE1BQU0sS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVELElBQUksV0FBVyxJQUFJLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDOUQsOEVBQThFO1FBQzlFLHdCQUF3QjtRQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLDhEQUE4RCxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVELE9BQU87UUFDTCxTQUFTLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBOEMsQ0FBQztRQUMvRSxLQUFLLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDO1FBQ2hDLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUE4QyxDQUFDO1FBQzNFLE1BQU0sRUFBRSxPQUFPLENBQUMsY0FBYztLQUMvQixDQUFDO0FBQ0osQ0FBQztBQUVELEtBQUssVUFBVSxTQUFTLENBQUMsT0FBNEM7SUFDbkUsdUZBQXVGO0lBQ3ZGLDZDQUE2QztJQUM3Qyw2Q0FBNkM7SUFDN0MsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLE1BQU0sRUFBRSxDQUFDO1FBQzlCLE9BQU87SUFDVCxDQUFDO0lBRUQsc0ZBQXNGO0lBQ3RGLHlGQUF5RjtJQUN6RiwyRkFBMkY7SUFDM0YsMkZBQTJGO0lBQzNGLGlDQUFpQztJQUNqQyxPQUFPLENBQUMsTUFBTSxDQUFDLG1CQUFtQixHQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQztJQUM5QyxPQUFPLENBQUMsTUFBTSxDQUFDLHNCQUFzQixHQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQztJQUVqRCxPQUFPLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxFQUFFO1FBQ2xDLE9BQU8sQ0FBQyxrQkFBbUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQ25DLGlFQUFpRTtZQUNqRSxtR0FBbUc7WUFDbkcsOENBQThDO1FBQ2hELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELEtBQUssVUFBVSxLQUFLLENBQ2xCLE9BQWdDLEVBQ2hDLEtBQVU7SUFFVixpQ0FBaUMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFbEQsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFMUQsSUFBSSxXQUFXLElBQUksQ0FBQyxDQUFDLGdCQUFnQixZQUFZLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFDMUQsTUFBTSxLQUFLLENBQ1Qsb0dBQW9HLE9BQU8sZ0JBQWdCLHlCQUF5QixDQUNySixDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sbUJBQW1CLEdBQXNDLE1BQU0sZ0JBQWdCLENBQUM7SUFFdEYsSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUNoQixJQUFJLENBQUMsbUJBQW1CLElBQUksT0FBTyxtQkFBbUIsQ0FBQyxPQUFPLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDOUUsTUFBTSxLQUFLLENBQ1QsNk1BQTZNLENBQzlNLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVELE1BQU0seUJBQXlCLEdBQzdCLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMseUJBQXlCLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFFcEUsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUM7SUFFaEQsMEZBQTBGO0lBQzFGLHNHQUFzRztJQUN0Ryw2RkFBNkY7SUFDN0YsMkVBQTJFO0lBQzNFLElBQUksV0FBVyxJQUFJLGFBQWEsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLHlCQUF5QixLQUFLLElBQUksRUFBRSxDQUFDO1FBQ3pGLE1BQU0sSUFBSSxLQUFLLENBQUM7O0tBRWYsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELE1BQU0sbUJBQW1CLEdBQUcsT0FBOEMsQ0FBQztJQUUzRSxJQUFJLGFBQWEsRUFBRSxDQUFDO1FBQ2xCLE1BQU0sTUFBTSxHQUFXLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXhFLDBGQUEwRjtRQUMxRiwyQkFBMkI7UUFDM0IsSUFBSSx5QkFBeUIsS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUN2QyxnREFBZ0QsQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNqRixDQUFDO1FBRUQsbUJBQW1CLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDO1FBQ2hELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQywwQkFBMEIsRUFBRSxtQkFBbUIsQ0FBQyxvQkFBcUIsQ0FBQyxDQUFDO0lBQ2pHLENBQUM7SUFFRCxtQkFBbUIsQ0FBQywrQkFBK0IsR0FBRyxtQkFBbUIsQ0FBQztJQUMxRSxPQUFPLG1CQUFtQixDQUFDO0FBQzdCLENBQUM7QUFFRCxTQUFTLE9BQU8sQ0FBQyxPQUE0QztJQUMzRCxPQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ2pDLElBQUksT0FBTyxDQUFDLG9CQUFvQixFQUFFLENBQUM7WUFDakMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLDBCQUEwQixFQUFFLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3ZGLENBQUM7UUFFRCxPQUFPLENBQUMsK0JBQWdDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkQsT0FBTyxDQUFDLCtCQUErQixHQUFHLElBQUksQ0FBQztJQUNqRCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLGdEQUFnRCxDQUN2RCxtQkFBc0QsRUFDdEQsT0FBZ0M7SUFFaEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUM3QiwrRUFBK0U7UUFDL0UsbUVBQW1FO1FBQ25FLE9BQU87SUFDVCxDQUFDO0lBRUQsTUFBTSxNQUFNLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEUsTUFBTSxZQUFZLEdBQWlCLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBVSxFQUFFLEVBQUU7UUFDeEUsSUFBSSxLQUFLLFlBQVksT0FBTyxDQUFDLGVBQWdCLEVBQUUsQ0FBQztZQUM5QyxNQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQ3hELDREQUE0RDtZQUM1RCxpQ0FBaUM7WUFDakMsa0VBQWtFO1lBQ2xFLDJEQUEyRDtZQUMzRCwwQkFBMEI7WUFDMUIsc0VBQXNFO1lBQ3RFLDBGQUEwRjtZQUMxRixJQUFJLGlCQUFpQixDQUFDLE9BQU8sS0FBSyxZQUFZLEVBQUUsQ0FBQztnQkFDL0MsaUJBQWlCLENBQUMsTUFBTSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztnQkFDbkQsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7WUFDOUMsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUNsRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwbGljYXRpb25SZWYsIE5nTW9kdWxlUmVmLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTGlmZUN5Y2xlcyB9IGZyb20gJ3NpbmdsZS1zcGEnO1xuaW1wb3J0IHsgZ2V0Q29udGFpbmVyRWxlbWVudEFuZFNldFRlbXBsYXRlIH0gZnJvbSAnc2luZ2xlLXNwYS1hbmd1bGFyL2ludGVybmFscyc7XG5cbmltcG9ydCB7IFNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gfSBmcm9tICcuL2V4dHJhLXByb3ZpZGVycyc7XG5pbXBvcnQgeyBTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucywgQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vIFJlcXVpcmVkIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHNldCBieSB0aGUgbGlicmFyeSBjb25zdW1lci5cbiAgTmdab25lOiBudWxsISxcbiAgYm9vdHN0cmFwRnVuY3Rpb246IG51bGwhLFxuICB0ZW1wbGF0ZTogbnVsbCEsXG4gIC8vIE9wdGlvbmFsIG9wdGlvbnNcbiAgUm91dGVyOiB1bmRlZmluZWQsXG4gIGRvbUVsZW1lbnRHZXR0ZXI6IHVuZGVmaW5lZCwgLy8gb25seSBvcHRpb25hbCBpZiB5b3UgcHJvdmlkZSBhIGRvbUVsZW1lbnRHZXR0ZXIgYXMgYSBjdXN0b20gcHJvcFxuICB1cGRhdGVGdW5jdGlvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXG4gIGJvb3RzdHJhcHBlZE5nTW9kdWxlUmVmT3JBcHBSZWY6IG51bGwsXG59O1xuXG4vLyBUaGlzIHdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJLiBUaGlzIHdpbGxcbi8vIGhlbHAgdG8gdHJlZS1zaGFrZSBhd2F5IHRoZSBjb2RlIHVubmVlZGVkIGZvciBwcm9kdWN0aW9uIGJ1bmRsZXMuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVTcGFBbmd1bGFyPFQ+KHVzZXJPcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9uczxUPik6IExpZmVDeWNsZXM8VD4ge1xuICBpZiAoTkdfREVWX01PREUgJiYgdHlwZW9mIHVzZXJPcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IEVycm9yKCdzaW5nbGUtc3BhLWFuZ3VsYXIgcmVxdWlyZXMgYSBjb25maWd1cmF0aW9uIG9iamVjdCcpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uczogU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4udXNlck9wdGlvbnMsXG4gIH07XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmIHR5cGVvZiBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ3NpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCBhbiBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoTkdfREVWX01PREUgJiYgdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ3NpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCBvcHRpb25zLnRlbXBsYXRlIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmICFvcHRpb25zLk5nWm9uZSkge1xuICAgIHRocm93IEVycm9yKGBzaW5nbGUtc3BhLWFuZ3VsYXIgbXVzdCBiZSBwYXNzZWQgdGhlIE5nWm9uZSBvcHRpb25gKTtcbiAgfVxuXG4gIGlmIChOR19ERVZfTU9ERSAmJiBvcHRpb25zLlJvdXRlciAmJiAhb3B0aW9ucy5OYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAvLyBXZSBjYWxsIGBjb25zb2xlLndhcm5gIGV4Y2VwdCBvZiB0aHJvd2luZyBgbmV3IEVycm9yKClgIHNpbmNlIHRoaXMgd2lsbCBub3RcbiAgICAvLyBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAgICBjb25zb2xlLndhcm4oYHNpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCB0aGUgTmF2aWdhdGlvblN0YXJ0IG9wdGlvbmApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBib290c3RyYXA6IGJvb3RzdHJhcC5iaW5kKG51bGwsIG9wdGlvbnMgYXMgQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMpLFxuICAgIG1vdW50OiBtb3VudC5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgIHVubW91bnQ6IHVubW91bnQuYmluZChudWxsLCBvcHRpb25zIGFzIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zKSxcbiAgICB1cGRhdGU6IG9wdGlvbnMudXBkYXRlRnVuY3Rpb24sXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJvb3RzdHJhcChvcHRpb25zOiBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBBbmd1bGFyIHByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIGRldmVsb3AgYHpvbmUtbGVzc2AgYXBwbGljYXRpb24sIHdoZXJlIGRldmVsb3BlcnNcbiAgLy8gaGF2ZSB0byB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gbWFudWFsbHkuXG4gIC8vIFNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvem9uZSNub29wem9uZVxuICBpZiAob3B0aW9ucy5OZ1pvbmUgPT09ICdub29wJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE5vdGUgdGhhdCB3ZSBoYXZlIHRvIG1ha2UgaXQgYSBub29wIGZ1bmN0aW9uIGJlY2F1c2UgaXQncyBhIHN0YXRpYyBwcm9wZXJ0eSBhbmQgbm90XG4gIC8vIGFuIGluc3RhbmNlIHByb3BlcnR5LiBXZSdyZSB1bmFibGUgdG8gY29uZmlndXJlIGl0IGZvciBtdWx0aXBsZSBhcHBzIHdoZW4gZGVwZW5kZW5jaWVzXG4gIC8vIGFyZSBzaGFyZWQgYW5kIHJlZmVyZW5jZSB0aGUgc2FtZSBgTmdab25lYCBjbGFzcy4gV2UgY2FuJ3QgZGV0ZXJtaW5lIHdoZXJlIHRoaXMgZnVuY3Rpb25cbiAgLy8gaXMgYmVpbmcgZXhlY3V0ZWQgb3IgdW5kZXIgd2hpY2ggYXBwbGljYXRpb24sIG1ha2luZyBpdCBkaWZmaWN1bHQgdG8gYXNzZXJ0IHdoZXRoZXIgdGhpc1xuICAvLyBhcHAgaXMgcnVubmluZyB1bmRlciBpdHMgem9uZS5cbiAgb3B0aW9ucy5OZ1pvbmUuYXNzZXJ0SW5Bbmd1bGFyWm9uZSA9ICgpID0+IHt9O1xuICBvcHRpb25zLk5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lID0gKCkgPT4ge307XG5cbiAgb3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICBvcHRpb25zLmJvb3RzdHJhcHBlZE5nWm9uZSEucnVuKCgpID0+IHtcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhLWFuZ3VsYXIvaXNzdWVzLzg2XG4gICAgICAvLyBab25lIGlzIHVuYXdhcmUgb2YgdGhlIHNpbmdsZS1zcGEgbmF2aWdhdGlvbiBjaGFuZ2UgYW5kIHNvIEFuZ3VsYXIgY2hhbmdlIGRldGVjdGlvbiBkb2Vzbid0IHdvcmtcbiAgICAgIC8vIHVubGVzcyB3ZSB0ZWxsIFpvbmUgdGhhdCBzb21ldGhpbmcgaGFwcGVuZWRcbiAgICB9KTtcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbW91bnQoXG4gIG9wdGlvbnM6IFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zLFxuICBwcm9wczogYW55LFxuKTogUHJvbWlzZTxOZ01vZHVsZVJlZjxhbnk+IHwgQXBwbGljYXRpb25SZWY+IHtcbiAgZ2V0Q29udGFpbmVyRWxlbWVudEFuZFNldFRlbXBsYXRlKG9wdGlvbnMsIHByb3BzKTtcblxuICBjb25zdCBib290c3RyYXBQcm9taXNlID0gb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbihwcm9wcyk7XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmICEoYm9vdHN0cmFwUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgc2luZ2xlLXNwYS1hbmd1bGFyOiB0aGUgb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbiBtdXN0IHJldHVybiBhIHByb21pc2UsIGJ1dCBpbnN0ZWFkIHJldHVybmVkIGEgJyR7dHlwZW9mIGJvb3RzdHJhcFByb21pc2V9JyB0aGF0IGlzIG5vdCBhIFByb21pc2VgLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBuZ01vZHVsZVJlZk9yQXBwUmVmOiBOZ01vZHVsZVJlZjxhbnk+IHwgQXBwbGljYXRpb25SZWYgPSBhd2FpdCBib290c3RyYXBQcm9taXNlO1xuXG4gIGlmIChOR19ERVZfTU9ERSkge1xuICAgIGlmICghbmdNb2R1bGVSZWZPckFwcFJlZiB8fCB0eXBlb2YgbmdNb2R1bGVSZWZPckFwcFJlZi5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYHNpbmdsZS1zcGEtYW5ndWxhcjogdGhlIG9wdGlvbnMuYm9vdHN0cmFwRnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlIHRoYXQgZGlkIG5vdCByZXNvbHZlIHdpdGggYSB2YWxpZCBBbmd1bGFyIG1vZHVsZSBvciBBcHBsaWNhdGlvblJlZi4gRGlkIHlvdSBjYWxsIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoKSBjb3JyZWN0bHk/YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbjogU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiB8IG51bGwgPVxuICAgIG5nTW9kdWxlUmVmT3JBcHBSZWYuaW5qZWN0b3IuZ2V0KFNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24sIG51bGwpO1xuXG4gIGNvbnN0IG5nWm9uZUVuYWJsZWQgPSBvcHRpb25zLk5nWm9uZSAhPT0gJ25vb3AnO1xuXG4gIC8vIFRoZSB1c2VyIGhhcyB0byBwcm92aWRlIGBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbmAgb25seSBpZiBoaXMgYXBwbGljYXRpb24gdXNlcyByb3V0aW5nLlxuICAvLyBTbyBpZiBoZSBwcm92aWRlZCBgUm91dGVyYCBidXQgZGlkbid0IHByb3ZpZGUgYEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uYCB0aGVuIHdlIGhhdmUgdG8gaW5mb3JtIGhpbS5cbiAgLy8gQWxzbyBgZ2V0U2luZ2xlU3BhRXh0cmFQcm92aWRlcnMoKWAgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGlmIHRoZSB1c2VyIGRvZXNuJ3QgdXNlXG4gIC8vIGB6b25lLWxlc3NgIGNoYW5nZSBkZXRlY3Rpb24sIGlmIGBOZ1pvbmVgIGlzIGBub29wYCB0aGVuIHdlIGNhbiBza2lwIGl0LlxuICBpZiAoTkdfREVWX01PREUgJiYgbmdab25lRW5hYmxlZCAmJiBvcHRpb25zLlJvdXRlciAmJiBzaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIHNpbmdsZS1zcGEtYW5ndWxhcjogY291bGQgbm90IHJldHJpZXZlIGV4dHJhIHByb3ZpZGVycyBmcm9tIHRoZSBwbGF0Zm9ybSBpbmplY3Rvci4gRGlkIHlvdSBjYWxsIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoZ2V0U2luZ2xlU3BhRXh0cmFQcm92aWRlcnMoKSkuYm9vdHN0cmFwTW9kdWxlKCk/XG4gICAgYCk7XG4gIH1cblxuICBjb25zdCBib290c3RyYXBwZWRPcHRpb25zID0gb3B0aW9ucyBhcyBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucztcblxuICBpZiAobmdab25lRW5hYmxlZCkge1xuICAgIGNvbnN0IG5nWm9uZTogTmdab25lID0gbmdNb2R1bGVSZWZPckFwcFJlZi5pbmplY3Rvci5nZXQob3B0aW9ucy5OZ1pvbmUpO1xuXG4gICAgLy8gYE5nWm9uZWAgY2FuIGJlIGVuYWJsZWQgYnV0IHJvdXRpbmcgbWF5IG5vdCBiZSB1c2VkIHRodXMgYGdldFNpbmdsZVNwYUV4dHJhUHJvdmlkZXJzKClgXG4gICAgLy8gZnVuY3Rpb24gd2FzIG5vdCBjYWxsZWQuXG4gICAgaWYgKHNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHNraXBMb2NhdGlvbkNoYW5nZU9uTm9uSW1wZXJhdGl2ZVJvdXRpbmdUcmlnZ2VycyhuZ01vZHVsZVJlZk9yQXBwUmVmLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBib290c3RyYXBwZWRPcHRpb25zLmJvb3RzdHJhcHBlZE5nWm9uZSA9IG5nWm9uZTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2luZ2xlLXNwYTpyb3V0aW5nLWV2ZW50JywgYm9vdHN0cmFwcGVkT3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lciEpO1xuICB9XG5cbiAgYm9vdHN0cmFwcGVkT3B0aW9ucy5ib290c3RyYXBwZWROZ01vZHVsZVJlZk9yQXBwUmVmID0gbmdNb2R1bGVSZWZPckFwcFJlZjtcbiAgcmV0dXJuIG5nTW9kdWxlUmVmT3JBcHBSZWY7XG59XG5cbmZ1bmN0aW9uIHVubW91bnQob3B0aW9uczogQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmIChvcHRpb25zLnJvdXRpbmdFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2luZ2xlLXNwYTpyb3V0aW5nLWV2ZW50Jywgb3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5ib290c3RyYXBwZWROZ01vZHVsZVJlZk9yQXBwUmVmIS5kZXN0cm95KCk7XG4gICAgb3B0aW9ucy5ib290c3RyYXBwZWROZ01vZHVsZVJlZk9yQXBwUmVmID0gbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNraXBMb2NhdGlvbkNoYW5nZU9uTm9uSW1wZXJhdGl2ZVJvdXRpbmdUcmlnZ2VycyhcbiAgbmdNb2R1bGVSZWZPckFwcFJlZjogTmdNb2R1bGVSZWY8YW55PiB8IEFwcGxpY2F0aW9uUmVmLFxuICBvcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyxcbik6IHZvaWQge1xuICBpZiAoIW9wdGlvbnMuTmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgLy8gQXMgZGlzY3Vzc2VkIHdlIGRvbid0IGRvIGFueXRoaW5nIHJpZ2h0IG5vdyBpZiB0aGUgZGV2ZWxvcGVyIGRvZXNuJ3QgcHJvdmlkZVxuICAgIC8vIGBvcHRpb25zLk5hdmlnYXRpb25TdGFydGAgc2luY2UgdGhpcyBtaWdodCBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCByb3V0ZXIgPSBuZ01vZHVsZVJlZk9yQXBwUmVmLmluamVjdG9yLmdldChvcHRpb25zLlJvdXRlcik7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoKGV2ZW50OiBhbnkpID0+IHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBvcHRpb25zLk5hdmlnYXRpb25TdGFydCEpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROYXZpZ2F0aW9uID0gcm91dGVyLmdldEN1cnJlbnROYXZpZ2F0aW9uKCk7XG4gICAgICAvLyBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgc2V0IHVwIGZvciBlYWNoIEFuZ3VsYXIgYXBwbGljYXRpb25cbiAgICAgIC8vIHRoYXQgaGFzIHJvdXRpbmcgY2FwYWJpbGl0aWVzLlxuICAgICAgLy8gV2Ugc2V0IGBza2lwTG9jYXRpb25DaGFuZ2VgIGZvciBlYWNoIG5vbi1pbXBlcmF0aXZlIG5hdmlnYXRpb24sXG4gICAgICAvLyBBbmd1bGFyIHJvdXRlciBjaGVja3MgdW5kZXIgdGhlIGhvb2QgaWYgaXQgaGFzIHRvIGNoYW5nZVxuICAgICAgLy8gdGhlIGJyb3dzZXIgVVJMIG9yIG5vdC5cbiAgICAgIC8vIElmIGBza2lwTG9jYXRpb25DaGFuZ2VgIGlzIHRydXRoeSB0aGVuIEFuZ3VsYXIgcm91dGVyIHdpbGwgbm90IGNhbGxcbiAgICAgIC8vIGBzZXRCcm93c2VyVXJsKClgIHdoaWNoIGNhbGxzIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZSgpYCBhbmQgZGlzcGF0Y2hlcyBgcG9wc3RhdGVgIGV2ZW50LlxuICAgICAgaWYgKGN1cnJlbnROYXZpZ2F0aW9uLnRyaWdnZXIgIT09ICdpbXBlcmF0aXZlJykge1xuICAgICAgICBjdXJyZW50TmF2aWdhdGlvbi5leHRyYXMuc2tpcExvY2F0aW9uQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudE5hdmlnYXRpb24uZXh0cmFzLnJlcGxhY2VVcmwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIG5nTW9kdWxlUmVmT3JBcHBSZWYub25EZXN0cm95KCgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpKTtcbn1cbiJdfQ==