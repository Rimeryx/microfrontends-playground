import { Injectable, Inject } from '@angular/core';
import { BrowserPlatformLocation, PlatformLocation, DOCUMENT, } from '@angular/common';
import * as i0 from "@angular/core";
export class SingleSpaPlatformLocation extends BrowserPlatformLocation {
    constructor() {
        super(...arguments);
        // This is a simple marker that helps us to ignore PopStateEvents
        // that was not dispatched by the browser.
        this.skipNextPopState = false;
        this.source = 'Window.addEventListener:popstate';
    }
    pushState(state, title, url) {
        this.skipNextPopState = true;
        super.pushState(state, title, url);
    }
    replaceState(state, title, url) {
        this.skipNextPopState = true;
        super.replaceState(state, title, url);
    }
    onPopState(fn) {
        // `Zone.current` will reference the zone that serves as an execution context
        // to some specific application, especially when `onPopState` is called.
        const zone = Zone.current;
        // Wrap any event listener into zone that is specific to some application.
        // The main issue is `back/forward` buttons of browsers, because they invoke
        // `history.back|forward` which dispatch `popstate` event. Since `single-spa`
        // overrides `history.replaceState` Angular's zone cannot intercept this event.
        // Only the root zone is able to intercept all events.
        // See https://github.com/single-spa/single-spa-angular/issues/94 for more details
        fn = zone.wrap(fn, this.source);
        const onPopStateListener = (event) => {
            // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added
            // by `single-spa` starting from `5.4` version. We need this check because we want
            // to skip "unnatural" PopStateEvents, the one caused by `single-spa`.
            const popStateEventWasDispatchedBySingleSpa = !!event
                .singleSpa;
            if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {
                this.skipNextPopState = false;
            }
            else {
                fn(event);
            }
        };
        return super.onPopState(onPopStateListener);
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.3", ngImport: i0, type: SingleSpaPlatformLocation, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.3", ngImport: i0, type: SingleSpaPlatformLocation }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.3", ngImport: i0, type: SingleSpaPlatformLocation, decorators: [{
            type: Injectable
        }] });
/**
 * The `PlatformLocation` class is an "injectee" of the `PathLocationStrategy`,
 * which creates `Subject` internally for listening on `popstate` events. We want
 * to provide this class in the most top injector that's used during bootstrapping.
 */
export function getSingleSpaExtraProviders() {
    return [
        {
            provide: SingleSpaPlatformLocation,
            deps: [[new Inject(DOCUMENT)]],
        },
        {
            provide: PlatformLocation,
            useExisting: SingleSpaPlatformLocation,
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmEtcHJvdmlkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGlicy9zaW5nbGUtc3BhLWFuZ3VsYXIvc3JjL2V4dHJhLXByb3ZpZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFrQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixnQkFBZ0IsRUFHaEIsUUFBUSxHQUNULE1BQU0saUJBQWlCLENBQUM7O0FBS3pCLE1BQU0sT0FBTyx5QkFBMEIsU0FBUSx1QkFBdUI7SUFEdEU7O1FBRUUsaUVBQWlFO1FBQ2pFLDBDQUEwQztRQUNsQyxxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFaEIsV0FBTSxHQUFHLGtDQUFrQyxDQUFDO0tBeUM5RDtJQXZDQyxTQUFTLENBQUMsS0FBVSxFQUFFLEtBQWEsRUFBRSxHQUFXO1FBQzlDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxZQUFZLENBQUMsS0FBVSxFQUFFLEtBQWEsRUFBRSxHQUFXO1FBQ2pELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxVQUFVLENBQUMsRUFBMEI7UUFDbkMsNkVBQTZFO1FBQzdFLHdFQUF3RTtRQUN4RSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBRTFCLDBFQUEwRTtRQUMxRSw0RUFBNEU7UUFDNUUsNkVBQTZFO1FBQzdFLCtFQUErRTtRQUMvRSxzREFBc0Q7UUFDdEQsa0ZBQWtGO1FBQ2xGLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFaEMsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEtBQTBCLEVBQUUsRUFBRTtZQUN4RCxvRkFBb0Y7WUFDcEYsa0ZBQWtGO1lBQ2xGLHNFQUFzRTtZQUN0RSxNQUFNLHFDQUFxQyxHQUFHLENBQUMsQ0FBRSxLQUEyQztpQkFDekYsU0FBUyxDQUFDO1lBRWIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLElBQUkscUNBQXFDLEVBQUUsQ0FBQztnQkFDbkUsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztZQUNoQyxDQUFDO2lCQUFNLENBQUM7Z0JBQ04sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ1osQ0FBQztRQUNILENBQUMsQ0FBQztRQUVGLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQzlDLENBQUM7aUlBN0NVLHlCQUF5QjtxSUFBekIseUJBQXlCOzsyRkFBekIseUJBQXlCO2tCQURyQyxVQUFVOztBQWlEWDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLDBCQUEwQjtJQUN4QyxPQUFPO1FBQ0w7WUFDRSxPQUFPLEVBQUUseUJBQXlCO1lBQ2xDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztTQUMvQjtRQUNEO1lBQ0UsT0FBTyxFQUFFLGdCQUFnQjtZQUN6QixXQUFXLEVBQUUseUJBQXlCO1NBQ3ZDO0tBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBTdGF0aWNQcm92aWRlciwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbixcbiAgUGxhdGZvcm1Mb2NhdGlvbixcbiAgTG9jYXRpb25DaGFuZ2VFdmVudCxcbiAgTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcixcbiAgRE9DVU1FTlQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmRlY2xhcmUgY29uc3QgWm9uZTogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiBleHRlbmRzIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uIHtcbiAgLy8gVGhpcyBpcyBhIHNpbXBsZSBtYXJrZXIgdGhhdCBoZWxwcyB1cyB0byBpZ25vcmUgUG9wU3RhdGVFdmVudHNcbiAgLy8gdGhhdCB3YXMgbm90IGRpc3BhdGNoZWQgYnkgdGhlIGJyb3dzZXIuXG4gIHByaXZhdGUgc2tpcE5leHRQb3BTdGF0ZSA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgc291cmNlID0gJ1dpbmRvdy5hZGRFdmVudExpc3RlbmVyOnBvcHN0YXRlJztcblxuICBwdXNoU3RhdGUoc3RhdGU6IGFueSwgdGl0bGU6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnNraXBOZXh0UG9wU3RhdGUgPSB0cnVlO1xuICAgIHN1cGVyLnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gIH1cblxuICByZXBsYWNlU3RhdGUoc3RhdGU6IGFueSwgdGl0bGU6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnNraXBOZXh0UG9wU3RhdGUgPSB0cnVlO1xuICAgIHN1cGVyLnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gIH1cblxuICBvblBvcFN0YXRlKGZuOiBMb2NhdGlvbkNoYW5nZUxpc3RlbmVyKTogVm9pZEZ1bmN0aW9uIHtcbiAgICAvLyBgWm9uZS5jdXJyZW50YCB3aWxsIHJlZmVyZW5jZSB0aGUgem9uZSB0aGF0IHNlcnZlcyBhcyBhbiBleGVjdXRpb24gY29udGV4dFxuICAgIC8vIHRvIHNvbWUgc3BlY2lmaWMgYXBwbGljYXRpb24sIGVzcGVjaWFsbHkgd2hlbiBgb25Qb3BTdGF0ZWAgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHpvbmUgPSBab25lLmN1cnJlbnQ7XG5cbiAgICAvLyBXcmFwIGFueSBldmVudCBsaXN0ZW5lciBpbnRvIHpvbmUgdGhhdCBpcyBzcGVjaWZpYyB0byBzb21lIGFwcGxpY2F0aW9uLlxuICAgIC8vIFRoZSBtYWluIGlzc3VlIGlzIGBiYWNrL2ZvcndhcmRgIGJ1dHRvbnMgb2YgYnJvd3NlcnMsIGJlY2F1c2UgdGhleSBpbnZva2VcbiAgICAvLyBgaGlzdG9yeS5iYWNrfGZvcndhcmRgIHdoaWNoIGRpc3BhdGNoIGBwb3BzdGF0ZWAgZXZlbnQuIFNpbmNlIGBzaW5nbGUtc3BhYFxuICAgIC8vIG92ZXJyaWRlcyBgaGlzdG9yeS5yZXBsYWNlU3RhdGVgIEFuZ3VsYXIncyB6b25lIGNhbm5vdCBpbnRlcmNlcHQgdGhpcyBldmVudC5cbiAgICAvLyBPbmx5IHRoZSByb290IHpvbmUgaXMgYWJsZSB0byBpbnRlcmNlcHQgYWxsIGV2ZW50cy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmdsZS1zcGEvc2luZ2xlLXNwYS1hbmd1bGFyL2lzc3Vlcy85NCBmb3IgbW9yZSBkZXRhaWxzXG4gICAgZm4gPSB6b25lLndyYXAoZm4sIHRoaXMuc291cmNlKTtcblxuICAgIGNvbnN0IG9uUG9wU3RhdGVMaXN0ZW5lciA9IChldmVudDogTG9jYXRpb25DaGFuZ2VFdmVudCkgPT4ge1xuICAgICAgLy8gVGhlIGBMb2NhdGlvbkNoYW5nZUV2ZW50YCBkb2Vzbid0IGhhdmUgdGhlIGBzaW5nbGVTcGFgIHByb3BlcnR5LCBzaW5jZSBpdCdzIGFkZGVkXG4gICAgICAvLyBieSBgc2luZ2xlLXNwYWAgc3RhcnRpbmcgZnJvbSBgNS40YCB2ZXJzaW9uLiBXZSBuZWVkIHRoaXMgY2hlY2sgYmVjYXVzZSB3ZSB3YW50XG4gICAgICAvLyB0byBza2lwIFwidW5uYXR1cmFsXCIgUG9wU3RhdGVFdmVudHMsIHRoZSBvbmUgY2F1c2VkIGJ5IGBzaW5nbGUtc3BhYC5cbiAgICAgIGNvbnN0IHBvcFN0YXRlRXZlbnRXYXNEaXNwYXRjaGVkQnlTaW5nbGVTcGEgPSAhIShldmVudCBhcyB1bmtub3duIGFzIHsgc2luZ2xlU3BhOiBib29sZWFuIH0pXG4gICAgICAgIC5zaW5nbGVTcGE7XG5cbiAgICAgIGlmICh0aGlzLnNraXBOZXh0UG9wU3RhdGUgJiYgcG9wU3RhdGVFdmVudFdhc0Rpc3BhdGNoZWRCeVNpbmdsZVNwYSkge1xuICAgICAgICB0aGlzLnNraXBOZXh0UG9wU3RhdGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHN1cGVyLm9uUG9wU3RhdGUob25Qb3BTdGF0ZUxpc3RlbmVyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgUGxhdGZvcm1Mb2NhdGlvbmAgY2xhc3MgaXMgYW4gXCJpbmplY3RlZVwiIG9mIHRoZSBgUGF0aExvY2F0aW9uU3RyYXRlZ3lgLFxuICogd2hpY2ggY3JlYXRlcyBgU3ViamVjdGAgaW50ZXJuYWxseSBmb3IgbGlzdGVuaW5nIG9uIGBwb3BzdGF0ZWAgZXZlbnRzLiBXZSB3YW50XG4gKiB0byBwcm92aWRlIHRoaXMgY2xhc3MgaW4gdGhlIG1vc3QgdG9wIGluamVjdG9yIHRoYXQncyB1c2VkIGR1cmluZyBib290c3RyYXBwaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2luZ2xlU3BhRXh0cmFQcm92aWRlcnMoKTogU3RhdGljUHJvdmlkZXJbXSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbixcbiAgICAgIGRlcHM6IFtbbmV3IEluamVjdChET0NVTUVOVCldXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IFBsYXRmb3JtTG9jYXRpb24sXG4gICAgICB1c2VFeGlzdGluZzogU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbixcbiAgICB9LFxuICBdO1xufVxuIl19