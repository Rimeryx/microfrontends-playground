{"version":3,"file":"single-spa.min.js","sources":["../../src/applications/app-errors.ts","../../src/applications/app.helpers.ts","../../src/lifecycles/lifecycle.helpers.ts","../../src/devtools/profiler.ts","../../src/lifecycles/init.ts","../../src/lifecycles/unmount.ts","../../src/lifecycles/mount.ts","../../src/parcels/mount-parcel.ts","../../src/lifecycles/update.ts","../../src/lifecycles/prop.helpers.ts","../../src/applications/timeouts.ts","../../src/lifecycles/load.ts","../../src/utils/runtime-environment.ts","../../src/navigation/navigation-events.ts","../../src/jquery-support.ts","../../src/lifecycles/unload.ts","../../src/applications/apps.ts","../../src/navigation/reroute.ts","../../src/start.ts","../../src/devtools/devtools.ts","../../src/single-spa.ts"],"sourcesContent":["import { AppOrParcel } from \"../lifecycles/lifecycle.helpers\";\nimport { AppOrParcelStatus, objectType, toName } from \"./app.helpers\";\n\nlet errorHandlers: ErrorHandler[] = [];\n\nexport type SingleSpaError = Error & {\n  appOrParcelName: string;\n};\n\nexport type ErrorHandler = (err: SingleSpaError) => any;\n\nexport function handleAppError(\n  err: Error,\n  app: AppOrParcel,\n  newStatus: AppOrParcelStatus,\n) {\n  const transformedErr = transformErr(err, app, newStatus);\n\n  if (errorHandlers.length) {\n    errorHandlers.forEach((handler) => handler(transformedErr));\n  } else {\n    setTimeout(() => {\n      throw transformedErr;\n    });\n  }\n}\n\nexport function addErrorHandler(handler) {\n  if (typeof handler !== \"function\") {\n    throw Error(\n      formatErrorMessage(\n        28,\n        __DEV__ && \"a single-spa error handler must be a function\",\n      ),\n    );\n  }\n\n  errorHandlers.push(handler);\n}\n\nexport function removeErrorHandler(handler) {\n  if (typeof handler !== \"function\") {\n    throw Error(\n      formatErrorMessage(\n        29,\n        __DEV__ && \"a single-spa error handler must be a function\",\n      ),\n    );\n  }\n\n  let removedSomething = false;\n  errorHandlers = errorHandlers.filter((h) => {\n    const isHandler = h === handler;\n    removedSomething = removedSomething || isHandler;\n    return !isHandler;\n  });\n\n  return removedSomething;\n}\n\nexport function formatErrorMessage(code, msg, ...args) {\n  return `single-spa minified message #${code}: ${\n    msg ? msg + \" \" : \"\"\n  }See https://single-spa.js.org/error/?code=${code}${\n    args.length ? `&arg=${args.join(\"&arg=\")}` : \"\"\n  }`;\n}\n\nexport function transformErr(\n  ogErr: Error,\n  appOrParcel: AppOrParcel,\n  newStatus: AppOrParcelStatus,\n): SingleSpaError {\n  const errPrefix = `${objectType(appOrParcel)} '${toName(\n    appOrParcel,\n  )}' died in status ${appOrParcel.status}: `;\n\n  let result: Error;\n\n  if (ogErr instanceof Error) {\n    try {\n      ogErr.message = errPrefix + ogErr.message;\n    } catch (err) {\n      /* Some errors have read-only message properties, in which case there is nothing\n       * that we can do.\n       */\n    }\n    result = ogErr;\n  } else {\n    console.warn(\n      formatErrorMessage(\n        30,\n        __DEV__ &&\n          `While ${appOrParcel.status}, '${toName(\n            appOrParcel,\n          )}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`,\n        appOrParcel.status,\n        toName(appOrParcel),\n      ),\n    );\n    try {\n      result = Error(errPrefix + JSON.stringify(ogErr));\n    } catch (err) {\n      // If it's not an Error and you can't stringify it, then what else can you even do to it?\n      result = ogErr;\n    }\n  }\n\n  const singleSpaErr = result as SingleSpaError;\n  singleSpaErr.appOrParcelName = toName(appOrParcel);\n\n  // We set the status after transforming the error so that the error message\n  // references the state the application was in before the status change.\n  appOrParcel.status = newStatus;\n\n  return singleSpaErr;\n}\n","import {\n  ActivityFn,\n  AppOrParcel,\n  CustomProps,\n  InternalParcel,\n  LoadApp,\n  ParcelMap,\n} from \"../lifecycles/lifecycle.helpers\";\nimport { handleAppError } from \"./app-errors\";\nimport { AppOrParcelTimeouts } from \"./timeouts\";\n\n// App statuses\nexport enum AppOrParcelStatus {\n  NOT_LOADED = \"NOT_LOADED\",\n  LOADING_SOURCE_CODE = \"LOADING_SOURCE_CODE\",\n  NOT_INITIALIZED = \"NOT_INITIALIZED\",\n  INITIALIZING = \"INITIALIZING\",\n  NOT_MOUNTED = \"NOT_MOUNTED\",\n  MOUNTING = \"MOUNTING\",\n  MOUNTED = \"MOUNTED\",\n  UPDATING = \"UPDATING\",\n  UNMOUNTING = \"UNMOUNTING\",\n  UNLOADING = \"UNLOADING\",\n  LOAD_ERROR = \"LOAD_ERROR\",\n  SKIP_BECAUSE_BROKEN = \"SKIP_BECAUSE_BROKEN\",\n}\n\nexport function isActive(app) {\n  return app.status === AppOrParcelStatus.MOUNTED;\n}\n\nexport function shouldBeActive(app) {\n  try {\n    return app.activeWhen(window.location);\n  } catch (err) {\n    handleAppError(err, app, AppOrParcelStatus.SKIP_BECAUSE_BROKEN);\n    return false;\n  }\n}\n\nexport function toName(app) {\n  return app.name;\n}\n\nexport function isParcel(\n  appOrParcel: AppOrParcel,\n): appOrParcel is InternalParcel {\n  return Boolean((appOrParcel as InternalParcel).unmountThisParcel);\n}\n\nexport function objectType(appOrParcel: AppOrParcel): \"parcel\" | \"application\" {\n  return isParcel(appOrParcel) ? \"parcel\" : \"application\";\n}\n\nexport interface InternalApplication {\n  name: string;\n  activeWhen: ActivityFn;\n  loadApp: LoadApp;\n  status: AppOrParcelStatus;\n  loadErrorTime: number;\n  parcels: ParcelMap;\n  customProps?: CustomProps;\n  // The ensureValidAppTimeouts function gets called once the app is loaded\n  timeouts?: AppOrParcelTimeouts;\n  devtools: AppDevtools;\n}\n\nexport interface AppDevtools {\n  overlays: {\n    options: OverlayOptions;\n    selectors: string[];\n  };\n}\n\n// https://github.com/single-spa/single-spa-inspector/blob/ac3e1ded68e94239dd02d04f8a094ed8e6dfefc2/src/inspected-window-helpers/overlay-helpers.js#L53\ninterface OverlayOptions {\n  color?: string;\n  background?: string;\n  classes?: string[];\n  height?: string;\n  left?: string;\n  position?: string;\n  top?: string;\n  width?: string;\n  zIndex?: string | number;\n  textColor?: string;\n  textBlocks?: string[];\n}\n","import {\n  toName,\n  AppOrParcelStatus,\n  InternalApplication,\n  AppDevtools,\n} from \"../applications/app.helpers\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { AppOrParcelTimeouts } from \"../applications/timeouts\";\n\nexport function validLifecycleFn(\n  fn: LifeCycleFn<unknown> | LifeCycleFn<unknown>[],\n): boolean {\n  return fn && (typeof fn === \"function\" || isArrayOfFns(fn));\n\n  function isArrayOfFns(arr) {\n    return (\n      Array.isArray(arr) && !arr.find((item) => typeof item !== \"function\")\n    );\n  }\n}\n\nexport function flattenFnArray(\n  appOrParcel: LifeCycles<unknown>,\n  lifecycle: string,\n  isParcel: boolean,\n): LifeCycleFn<unknown> {\n  let fns: LifeCycleFn<unknown>[] = Array.isArray(appOrParcel[lifecycle])\n    ? (appOrParcel[lifecycle] as LifeCycleFn<unknown>[])\n    : [appOrParcel[lifecycle] as LifeCycleFn<unknown>].filter(Boolean);\n  if (fns.length === 0) {\n    fns = [() => Promise.resolve()];\n  }\n\n  const type = isParcel ? \"parcel\" : \"application\";\n  const name = toName(appOrParcel);\n\n  return function (props: AppProps): Promise<unknown> {\n    return fns.reduce((resultPromise, fn, index) => {\n      return resultPromise.then(() => {\n        const thisPromise = fn(props);\n        return smellsLikeAPromise(thisPromise)\n          ? thisPromise\n          : Promise.reject(\n              formatErrorMessage(\n                15,\n                __DEV__ &&\n                  `Within ${type} ${name}, the lifecycle function ${lifecycle} at array index ${index} did not return a promise`,\n                type,\n                name,\n                lifecycle,\n                index,\n              ),\n            );\n      });\n    }, Promise.resolve());\n  };\n}\n\nexport function smellsLikeAPromise(promise) {\n  return (\n    promise &&\n    typeof promise.then === \"function\" &&\n    typeof promise.catch === \"function\"\n  );\n}\n\nexport interface CustomProps {\n  [str: string]: any;\n  [num: number]: any;\n}\n\nexport interface ParcelCustomProps extends CustomProps {\n  domElement: HTMLElement;\n}\n\nexport type CustomPropsFn<ExtraProps extends CustomProps = CustomProps> = (\n  name: string,\n  location: Location,\n) => ExtraProps;\n\nexport type AppProps = {\n  name: string;\n  mountParcel(\n    parcelConfig: ParcelConfig,\n    customProps: ParcelProps & CustomProps,\n  ): Parcel;\n};\n\nexport type ParcelConfig<ExtraProps = CustomProps> =\n  | ParcelConfigObject<ExtraProps>\n  | (() => Promise<ParcelConfigObject<ExtraProps>>);\n\ntype ParcelProps = { domElement: HTMLElement };\nexport type ParcelConfigObject<ExtraProps = CustomProps> = {\n  name?: string;\n  timeouts?: AppOrParcelTimeouts;\n} & LifeCycles<ExtraProps>;\n\nexport type LifeCycleFn<ExtraProps> = (\n  config: ExtraProps & AppProps,\n) => Promise<any>;\nexport type LifeCycles<ExtraProps = {}> = {\n  init?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  mount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  unmount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  update?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  unload?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  devtools?: AppDevtools;\n  timeouts?: AppOrParcelTimeouts;\n};\n\nexport type Parcel<ExtraProps = CustomProps> = {\n  mount(): Promise<null>;\n  unmount(): Promise<null>;\n  update?(customProps: ExtraProps): Promise<any>;\n  getStatus(): AppOrParcelStatus;\n  loadPromise: Promise<null>;\n  initPromise: Promise<null>;\n  mountPromise: Promise<null>;\n  unmountPromise: Promise<null>;\n  // Intended for internal use only\n  _parcel: InternalParcel;\n};\n\nexport interface ParcelOwner {\n  name: string;\n  parcels: ParcelMap;\n}\n\nexport interface ParcelMap {\n  [parcelId: number]: InternalParcel;\n}\n\n// Intended for internal use only\nexport interface InternalParcel {\n  id: number;\n  name: string;\n  init: LifeCycles[\"init\"];\n  mount: LifeCycles[\"mount\"];\n  unmount: LifeCycles[\"unmount\"];\n  update: LifeCycles[\"update\"];\n  parcels: ParcelMap;\n  status: AppOrParcelStatus;\n  customProps: CustomProps;\n  parentName: string;\n  unmountThisParcel(): Promise<AppOrParcel>;\n  currentTask: Promise<LoadedAppOrParcel>;\n  timeouts: AppOrParcelTimeouts;\n}\n\nexport type AppOrParcel = InternalApplication | InternalParcel;\n\ninterface Loaded extends LifeCycles {\n  // loadPromise sometimes bails early if there is an error,\n  // which results in it being an InternalApplication\n  loadPromise?: Promise<LoadedApp | InternalApplication>;\n}\n\nexport type LoadedAppOrParcel =\n  | (InternalApplication & Loaded)\n  | (InternalParcel & Loaded);\n\nexport type LoadedApp = InternalApplication & Loaded;\n\nexport type Application<ExtraProps = {}> =\n  | LifeCycles<ExtraProps>\n  | LoadApp<ExtraProps>;\n\nexport type LoadApp<ExtraProps = {}> = (\n  config: ExtraProps & AppProps,\n) => Promise<LifeCycles<ExtraProps>>;\n\nexport interface SingleSpaLocation {\n  pathname: URL[\"pathname\"];\n  hash?: URL[\"hash\"];\n  search?: string;\n}\n\nexport type ActivityFn = (location: SingleSpaLocation) => boolean;\n\nexport type Activity = ActivityFn | string | (ActivityFn | string)[];\n\nexport type RegisterApplicationConfig<ExtraProps extends CustomProps = {}> = {\n  name: string;\n  app: Application<ExtraProps>;\n  activeWhen: Activity;\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>;\n};\n","let profileEntries: ProfileEntry[] = [];\n\nexport interface ProfileEntry {\n  type: \"application\" | \"parcel\" | \"routing\";\n  name: string;\n  kind:\n    | \"init\"\n    | \"load\"\n    | \"mount\"\n    | \"unload\"\n    | \"unmount\"\n    | \"update\"\n    | \"loadApps\"\n    | \"silentNavigation\"\n    | \"browserNavigation\"\n    | \"triggerAppChange\";\n  operationSucceeded: boolean;\n  start: number;\n  end: number;\n}\n\nexport function getProfilerData() {\n  return profileEntries;\n}\n\nexport function addProfileEntry(\n  type: ProfileEntry[\"type\"],\n  name: ProfileEntry[\"name\"],\n  kind: ProfileEntry[\"kind\"],\n  start: ProfileEntry[\"start\"],\n  end: ProfileEntry[\"end\"],\n  operationSucceeded: ProfileEntry[\"operationSucceeded\"],\n): void {\n  profileEntries.push({\n    type,\n    name,\n    start,\n    end,\n    kind,\n    operationSucceeded,\n  });\n}\n\nexport function clearProfilerData(): void {\n  profileEntries = [];\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  isParcel,\n} from \"../applications/app.helpers\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { handleAppError, transformErr } from \"../applications/app-errors\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nexport function toInitPromise(\n  appOrParcel: LoadedAppOrParcel,\n  hardFail?: boolean,\n): Promise<LoadedAppOrParcel> {\n  let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== AppOrParcelStatus.NOT_INITIALIZED) {\n      return appOrParcel;\n    }\n\n    if (__PROFILE__) {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    appOrParcel.status = AppOrParcelStatus.INITIALIZING;\n\n    return reasonableTime(appOrParcel, \"init\")\n      .then(successfulInit)\n      .catch((err) => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"init\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        if (hardFail) {\n          throw transformErr(\n            err,\n            appOrParcel,\n            AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n          );\n        } else {\n          handleAppError(\n            err,\n            appOrParcel,\n            AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n          );\n          return appOrParcel;\n        }\n      });\n  });\n\n  function successfulInit(): LoadedAppOrParcel {\n    appOrParcel.status = AppOrParcelStatus.NOT_MOUNTED;\n\n    if (__PROFILE__) {\n      addProfileEntry(\n        profileEventType,\n        toName(appOrParcel),\n        \"init\",\n        startTime,\n        performance.now(),\n        true,\n      );\n    }\n\n    return appOrParcel;\n  }\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  isParcel,\n} from \"../applications/app.helpers\";\nimport { handleAppError, transformErr } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nexport function toUnmountPromise(\n  appOrParcel: LoadedAppOrParcel,\n  hardFail?: boolean,\n): Promise<LoadedAppOrParcel> {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== AppOrParcelStatus.MOUNTED) {\n      return appOrParcel;\n    }\n\n    let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n    if (__PROFILE__) {\n      startTime = performance.now();\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n    }\n\n    appOrParcel.status = AppOrParcelStatus.UNMOUNTING;\n\n    const unmountChildrenParcels = Object.keys(appOrParcel.parcels).map(\n      (parcelId) => appOrParcel.parcels[parcelId].unmountThisParcel(),\n    );\n\n    let parcelError: Error;\n\n    return Promise.all(unmountChildrenParcels)\n      .then(unmountAppOrParcel, (parcelError) => {\n        // There is a parcel unmount error\n        return unmountAppOrParcel().then(() => {\n          // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n          const parentError = Error(parcelError.message);\n          if (hardFail) {\n            throw transformErr(\n              parentError,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          } else {\n            handleAppError(\n              parentError,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          }\n        });\n      })\n      .then(() => appOrParcel);\n\n    function unmountAppOrParcel() {\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      return reasonableTime(appOrParcel, \"unmount\").then(\n        () => {\n          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelError) {\n            appOrParcel.status = AppOrParcelStatus.NOT_MOUNTED;\n          }\n\n          if (__PROFILE__) {\n            addProfileEntry(\n              profileEventType,\n              toName(appOrParcel),\n              \"unmount\",\n              startTime,\n              performance.now(),\n              true,\n            );\n          }\n        },\n        (err) => {\n          if (__PROFILE__) {\n            addProfileEntry(\n              profileEventType,\n              toName(appOrParcel),\n              \"unmount\",\n              startTime,\n              performance.now(),\n              false,\n            );\n          }\n\n          if (hardFail) {\n            throw transformErr(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          } else {\n            handleAppError(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          }\n        },\n      );\n    }\n  });\n}\n","import {\n  toName,\n  isParcel,\n  AppOrParcelStatus,\n} from \"../applications/app.helpers\";\nimport { handleAppError, transformErr } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { toUnmountPromise } from \"./unmount\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nlet beforeFirstMountFired: boolean = false;\nlet firstMountFired: boolean = false;\n\nexport function toMountPromise(\n  appOrParcel: LoadedAppOrParcel,\n  hardFail?: boolean,\n): Promise<LoadedAppOrParcel> {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== AppOrParcelStatus.NOT_MOUNTED) {\n      return appOrParcel;\n    }\n\n    let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n    if (__PROFILE__) {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new CustomEvent(\"single-spa:before-first-mount\"));\n      beforeFirstMountFired = true;\n    }\n\n    appOrParcel.status = AppOrParcelStatus.MOUNTING;\n\n    return reasonableTime(appOrParcel, \"mount\")\n      .then(() => {\n        appOrParcel.status = AppOrParcelStatus.MOUNTED;\n\n        if (!firstMountFired) {\n          window.dispatchEvent(new CustomEvent(\"single-spa:first-mount\"));\n          firstMountFired = true;\n        }\n\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"mount\",\n            startTime,\n            performance.now(),\n            true,\n          );\n        }\n\n        return appOrParcel;\n      })\n      .catch((err) => {\n        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        appOrParcel.status = AppOrParcelStatus.MOUNTED;\n        return toUnmountPromise(appOrParcel, true).then(\n          setSkipBecauseBroken,\n          setSkipBecauseBroken,\n        );\n\n        function setSkipBecauseBroken() {\n          if (__PROFILE__) {\n            addProfileEntry(\n              profileEventType,\n              toName(appOrParcel),\n              \"mount\",\n              startTime,\n              performance.now(),\n              false,\n            );\n          }\n\n          if (!hardFail) {\n            handleAppError(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n            return appOrParcel;\n          } else {\n            throw transformErr(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          }\n        }\n      });\n  });\n}\n","import {\n  validLifecycleFn,\n  flattenFnArray,\n  CustomProps,\n  Parcel,\n  ParcelCustomProps,\n  ParcelConfigObject,\n  ParcelConfig,\n  ParcelOwner,\n  InternalParcel,\n} from \"../lifecycles/lifecycle.helpers\";\nimport { AppOrParcelStatus, toName } from \"../applications/app.helpers\";\nimport { toInitPromise } from \"../lifecycles/init\";\nimport { toMountPromise } from \"../lifecycles/mount\";\nimport { toUpdatePromise } from \"../lifecycles/update\";\nimport { toUnmountPromise } from \"../lifecycles/unmount\";\nimport { ensureValidAppTimeouts } from \"../applications/timeouts\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\n\nlet parcelCount: number = 0;\nconst rootParcels: ParcelOwner = { name: \"rootParcels\", parcels: {} };\n\n// This is a public api, exported to users of single-spa\nexport function mountRootParcel(\n  config: ParcelConfig,\n  customProps: CustomProps,\n) {\n  return mountParcel.call(rootParcels, config, customProps);\n}\n\nexport function mountParcel(\n  this: ParcelOwner,\n  config: ParcelConfig,\n  customProps: ParcelCustomProps,\n) {\n  const owningAppOrParcel = this;\n\n  // Validate inputs\n  if (!config || (typeof config !== \"object\" && typeof config !== \"function\")) {\n    throw Error(\n      formatErrorMessage(\n        2,\n        __DEV__ &&\n          \"Cannot mount parcel without a config object or config loading function\",\n      ),\n    );\n  }\n\n  if (config.name && typeof config.name !== \"string\") {\n    throw Error(\n      formatErrorMessage(\n        3,\n        __DEV__ &&\n          `Parcel name must be a string, if provided. Was given ${typeof config.name}`,\n        typeof config.name,\n      ),\n    );\n  }\n\n  const id = parcelCount++;\n  let name = config.name || `parcel-${id}`;\n\n  if (typeof customProps !== \"object\") {\n    throw Error(\n      formatErrorMessage(\n        4,\n        __DEV__ &&\n          `Parcel ${name} has invalid customProps -- must be an object but was given ${typeof customProps}`,\n        name,\n        typeof customProps,\n      ),\n    );\n  }\n\n  if (!customProps.domElement) {\n    throw Error(\n      formatErrorMessage(\n        5,\n        __DEV__ &&\n          `Parcel ${name} cannot be mounted without a domElement provided as a prop`,\n        name,\n      ),\n    );\n  }\n\n  const passedConfigLoadingFunction = typeof config === \"function\";\n  const configLoadingFunction: () => Promise<ParcelConfigObject<CustomProps>> =\n    passedConfigLoadingFunction ? config : () => Promise.resolve(config);\n\n  // Internal representation\n  const parcel: Partial<InternalParcel> = {\n    id,\n    parcels: {},\n    status: passedConfigLoadingFunction\n      ? AppOrParcelStatus.LOADING_SOURCE_CODE\n      : AppOrParcelStatus.NOT_INITIALIZED,\n    customProps,\n    parentName: toName(owningAppOrParcel),\n    currentTask: undefined,\n    unmountThisParcel() {\n      return parcel.currentTask.then(() => {\n        if (parcel.status !== AppOrParcelStatus.MOUNTED) {\n          throw Error(\n            formatErrorMessage(\n              6,\n              __DEV__ &&\n                `Cannot unmount parcel '${name}' -- it is in a ${parcel.status} status`,\n              name,\n              parcel.status,\n            ),\n          );\n        }\n\n        return toUnmountPromise(parcel as InternalParcel, true)\n          .then((value) => {\n            if (parcel.parentName) {\n              delete owningAppOrParcel.parcels[parcel.id];\n            }\n\n            return value;\n          })\n          .then((value) => {\n            resolveUnmount(value);\n            return value;\n          })\n          .catch((err) => {\n            parcel.status = AppOrParcelStatus.SKIP_BECAUSE_BROKEN;\n            rejectUnmount(err);\n            throw err;\n          });\n      });\n    },\n  };\n\n  let loadPromise = configLoadingFunction();\n\n  if (!loadPromise || typeof loadPromise.then !== \"function\") {\n    throw Error(\n      formatErrorMessage(\n        7,\n        __DEV__ &&\n          `When mounting a parcel, the config loading function must return a promise that resolves with the parcel config`,\n      ),\n    );\n  }\n\n  loadPromise = loadPromise.then((config) => {\n    if (!config) {\n      throw Error(\n        formatErrorMessage(\n          8,\n          __DEV__ &&\n            `When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config`,\n        ),\n      );\n    }\n\n    name = config.name || `parcel-${id}`;\n\n    if (\n      // ES Module objects don't have the object prototype\n      Object.prototype.hasOwnProperty.call(config, \"init\") &&\n      !validLifecycleFn(config.init)\n    ) {\n      throw Error(\n        formatErrorMessage(\n          9,\n          __DEV__ && `Parcel ${name} provided an invalid init function`,\n          name,\n        ),\n      );\n    }\n\n    if (!validLifecycleFn(config.mount)) {\n      throw Error(\n        formatErrorMessage(\n          10,\n          __DEV__ && `Parcel ${name} must have a valid mount function`,\n          name,\n        ),\n      );\n    }\n\n    if (!validLifecycleFn(config.unmount)) {\n      throw Error(\n        formatErrorMessage(\n          11,\n          __DEV__ && `Parcel ${name} must have a valid unmount function`,\n          name,\n        ),\n      );\n    }\n\n    if (config.update && !validLifecycleFn(config.update)) {\n      throw Error(\n        formatErrorMessage(\n          12,\n          __DEV__ && `Parcel ${name} provided an invalid update function`,\n          name,\n        ),\n      );\n    }\n\n    const init = flattenFnArray(\n      config,\n      config.init ? \"init\" : \"bootstrap\",\n      true,\n    );\n    const mount = flattenFnArray(config, \"mount\", true);\n    const unmount = flattenFnArray(config, \"unmount\", true);\n\n    parcel.status = AppOrParcelStatus.NOT_INITIALIZED;\n    parcel.name = name;\n    parcel.init = init;\n    parcel.mount = mount;\n    parcel.unmount = unmount;\n    parcel.timeouts = ensureValidAppTimeouts(config.timeouts);\n\n    if (config.update) {\n      parcel.update = flattenFnArray(config, \"update\", true);\n    }\n\n    const fullParcel: InternalParcel = parcel as InternalParcel;\n\n    // Add to owning app or parcel\n    owningAppOrParcel.parcels[id] = fullParcel;\n\n    return config;\n  });\n\n  // Start initializing and mounting\n  // The .then() causes the work to be put on the event loop instead of happening immediately\n  const initPromise = loadPromise.then(() =>\n    toInitPromise(parcel as InternalParcel, true),\n  );\n\n  const mountPromise = initPromise.then(\n    () => (parcel.currentTask = toMountPromise(parcel as InternalParcel, true)),\n  );\n  parcel.currentTask = mountPromise;\n\n  let resolveUnmount, rejectUnmount;\n\n  const unmountPromise = new Promise((resolve, reject) => {\n    resolveUnmount = resolve;\n    rejectUnmount = reject;\n  });\n\n  let externalRepresentation: Parcel = {\n    mount() {\n      return promiseWithoutReturnValue(\n        Promise.resolve().then(() => {\n          if (parcel.status !== AppOrParcelStatus.NOT_MOUNTED) {\n            throw Error(\n              formatErrorMessage(\n                13,\n                __DEV__ &&\n                  `Cannot mount parcel '${name}' -- it is in a ${parcel.status} status`,\n                name,\n                parcel.status,\n              ),\n            );\n          }\n\n          // Add to owning app or parcel\n          owningAppOrParcel.parcels[id] = parcel as InternalParcel;\n\n          return toMountPromise(parcel as InternalParcel);\n        }),\n      );\n    },\n    unmount() {\n      return promiseWithoutReturnValue(parcel.unmountThisParcel());\n    },\n    getStatus() {\n      return parcel.status;\n    },\n    loadPromise: promiseWithoutReturnValue(loadPromise),\n    initPromise: promiseWithoutReturnValue(initPromise),\n    mountPromise: promiseWithoutReturnValue(mountPromise),\n    unmountPromise: promiseWithoutReturnValue(unmountPromise),\n    _parcel: parcel as InternalParcel,\n  };\n\n  loadPromise.then(\n    (config) => {\n      if (config.update) {\n        externalRepresentation.update = function (customProps) {\n          return (parcel.currentTask = parcel.currentTask.then(() => {\n            parcel.customProps = customProps;\n\n            return promiseWithoutReturnValue(\n              toUpdatePromise(parcel as InternalParcel),\n            );\n          }));\n        };\n      }\n    },\n    () => {\n      // This catch handler avoids unhandled rejections.\n      // User code can handle the rejection via externalRepresentation.loadPromise.catch\n    },\n  );\n\n  return externalRepresentation;\n}\n\nfunction promiseWithoutReturnValue(promise) {\n  return promise.then(() => null);\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  isParcel,\n} from \"../applications/app.helpers\";\nimport { transformErr, formatErrorMessage } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nexport function toUpdatePromise(\n  appOrParcel: LoadedAppOrParcel,\n): Promise<LoadedAppOrParcel> {\n  return Promise.resolve().then(() => {\n    let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n    if (__PROFILE__) {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    if (appOrParcel.status !== AppOrParcelStatus.MOUNTED) {\n      throw Error(\n        formatErrorMessage(\n          32,\n          __DEV__ &&\n            `Cannot update parcel '${toName(\n              appOrParcel,\n            )}' because it is not mounted`,\n          toName(appOrParcel),\n        ),\n      );\n    }\n\n    appOrParcel.status = AppOrParcelStatus.UPDATING;\n\n    return reasonableTime(appOrParcel, \"update\")\n      .then(() => {\n        appOrParcel.status = AppOrParcelStatus.MOUNTED;\n\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"update\",\n            startTime,\n            performance.now(),\n            true,\n          );\n        }\n\n        return appOrParcel;\n      })\n      .catch((err) => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"update\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        throw transformErr(\n          err,\n          appOrParcel,\n          AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n        );\n      });\n  });\n}\n","import { mountParcel } from \"../parcels/mount-parcel\";\nimport { isParcel, toName } from \"../applications/app.helpers\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { AppOrParcel, CustomProps, InternalParcel } from \"./lifecycle.helpers\";\n\ninterface SingleSpaProps {\n  name: string;\n  mountParcel: typeof mountParcel;\n  unmountSelf(): Promise<AppOrParcel>;\n}\n\nexport function getProps(\n  appOrParcel: AppOrParcel,\n): SingleSpaProps & CustomProps {\n  const name = toName(appOrParcel);\n  let customProps =\n    typeof appOrParcel.customProps === \"function\"\n      ? appOrParcel.customProps(name, window.location)\n      : appOrParcel.customProps;\n  if (\n    typeof customProps !== \"object\" ||\n    customProps === null ||\n    Array.isArray(customProps)\n  ) {\n    customProps = {};\n    console.warn(\n      formatErrorMessage(\n        40,\n        __DEV__ &&\n          `single-spa: ${name}'s customProps function must return an object. Received ${customProps}`,\n      ),\n      name,\n      customProps,\n    );\n  }\n  const result: SingleSpaProps = Object.assign({}, customProps, {\n    name,\n    mountParcel: mountParcel.bind(appOrParcel),\n  });\n\n  if (isParcel(appOrParcel)) {\n    result.unmountSelf = appOrParcel.unmountThisParcel;\n  }\n\n  return result;\n}\n","import { getProps } from \"../lifecycles/prop.helpers\";\nimport { objectType, toName } from \"./app.helpers\";\nimport { formatErrorMessage } from \"./app-errors\";\nimport { AppOrParcel } from \"../lifecycles/lifecycle.helpers\";\n\nexport interface AppOrParcelTimeouts {\n  init: Timeout;\n  mount: Timeout;\n  unmount: Timeout;\n  unload: Timeout;\n  update: Timeout;\n}\n\nexport interface Timeout {\n  millis: number;\n  dieOnTimeout: boolean;\n  warningMillis: number;\n}\n\nconst defaultWarningMillis: number = 1000;\n\nconst globalTimeoutConfig: AppOrParcelTimeouts = {\n  init: {\n    millis: 4000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  mount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unmount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unload: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  update: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n};\n\nexport function setInitMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n): void {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        16,\n        __DEV__ &&\n          `init max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.init = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function setMountMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n): void {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        17,\n        __DEV__ &&\n          `mount max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.mount = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function setUnmountMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        18,\n        __DEV__ &&\n          `unmount max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.unmount = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function setUnloadMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        19,\n        __DEV__ &&\n          `unload max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.unload = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function reasonableTime(\n  appOrParcel: AppOrParcel,\n  lifecycle: \"init\" | \"mount\" | \"update\" | \"unmount\" | \"unload\",\n): Promise<any> {\n  const timeoutConfig = appOrParcel.timeouts[lifecycle];\n  const warningPeriod = timeoutConfig.warningMillis;\n  const type = objectType(appOrParcel);\n\n  return new Promise((resolve, reject) => {\n    let finished: boolean = false;\n    let errored: boolean = false;\n\n    appOrParcel[lifecycle](getProps(appOrParcel))\n      .then((val) => {\n        finished = true;\n        resolve(val);\n      })\n      .catch((val) => {\n        finished = true;\n        reject(val);\n      });\n\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n    const errMsg = formatErrorMessage(\n      31,\n      __DEV__ &&\n        `Lifecycle function ${lifecycle} for ${type} ${toName(\n          appOrParcel,\n        )} lifecycle did not resolve or reject for ${timeoutConfig.millis} ms.`,\n      lifecycle,\n      type,\n      toName(appOrParcel),\n      timeoutConfig.millis,\n    );\n\n    function maybeTimingOut(shouldError: true | number) {\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n          if (timeoutConfig.dieOnTimeout) {\n            reject(Error(errMsg));\n          } else {\n            console.error(errMsg);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          const numWarnings: number = shouldError;\n          const numMillis = numWarnings * warningPeriod;\n          console.warn(errMsg);\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\n\nexport function ensureValidAppTimeouts(\n  timeouts: Partial<AppOrParcelTimeouts>,\n): AppOrParcelTimeouts {\n  const result = {};\n\n  for (let key in globalTimeoutConfig) {\n    result[key] = Object.assign(\n      {},\n      globalTimeoutConfig[key],\n      timeouts?.[key] ?? {},\n    );\n  }\n\n  return result as AppOrParcelTimeouts;\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  InternalApplication,\n} from \"../applications/app.helpers\";\nimport { ensureValidAppTimeouts } from \"../applications/timeouts\";\nimport { handleAppError, formatErrorMessage } from \"../applications/app-errors\";\nimport {\n  LifeCycles,\n  LoadedApp,\n  flattenFnArray,\n  smellsLikeAPromise,\n  validLifecycleFn,\n} from \"./lifecycle.helpers\";\nimport { getProps } from \"./prop.helpers\";\nimport { addProfileEntry } from \"../devtools/profiler\";\n\nexport function toLoadPromise(\n  app: InternalApplication | LoadedApp,\n): Promise<LoadedApp | InternalApplication> {\n  return Promise.resolve().then(() => {\n    if ((app as LoadedApp).loadPromise) {\n      return (app as LoadedApp).loadPromise;\n    }\n\n    if (\n      app.status !== AppOrParcelStatus.NOT_LOADED &&\n      app.status !== AppOrParcelStatus.LOAD_ERROR\n    ) {\n      return app;\n    }\n\n    let startTime: number;\n    if (__PROFILE__) {\n      startTime = performance.now();\n    }\n\n    const appBeingLoaded: InternalApplication & Partial<LoadedApp> = app;\n\n    appBeingLoaded.status = AppOrParcelStatus.LOADING_SOURCE_CODE;\n\n    let lifecycles: LifeCycles, isUserErr: boolean;\n\n    return (appBeingLoaded.loadPromise = Promise.resolve()\n      .then(() => {\n        const loadPromise = appBeingLoaded.loadApp(getProps(app));\n        if (!smellsLikeAPromise(loadPromise)) {\n          // The name of the app will be prepended to this error message inside of the handleAppError function\n          isUserErr = true;\n          throw Error(\n            formatErrorMessage(\n              33,\n              __DEV__ &&\n                `single-spa loading function did not return a promise. Check the second argument to registerApplication('${toName(\n                  app,\n                )}', loadingFunction, activityFunction)`,\n              toName(appBeingLoaded),\n            ),\n          );\n        }\n        return loadPromise.then((val) => {\n          appBeingLoaded.loadErrorTime = null;\n\n          lifecycles = val;\n\n          let validationErrMessage, validationErrCode;\n\n          if (typeof lifecycles !== \"object\") {\n            validationErrCode = 34;\n            if (__DEV__) {\n              validationErrMessage = `does not export anything`;\n            }\n          }\n\n          if (!validLifecycleFn(lifecycles.mount)) {\n            validationErrCode = 36;\n            if (__DEV__) {\n              validationErrMessage = `does not export a mount function or array of functions`;\n            }\n          }\n\n          if (!validLifecycleFn(lifecycles.unmount)) {\n            validationErrCode = 37;\n            if (__DEV__) {\n              validationErrMessage = `does not export a unmount function or array of functions`;\n            }\n          }\n\n          if (validationErrCode) {\n            let appOptsStr;\n            try {\n              appOptsStr = JSON.stringify(lifecycles);\n            } catch {}\n            console.error(\n              formatErrorMessage(\n                validationErrCode,\n                __DEV__ &&\n                  `The loading function for single-spa application '${toName(\n                    appBeingLoaded,\n                  )}' resolved with the following, which does not have mount and unmount functions`,\n                \"application\",\n                toName(appBeingLoaded),\n                appOptsStr,\n              ),\n              lifecycles,\n            );\n            handleAppError(\n              validationErrMessage,\n              appBeingLoaded,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n            return appBeingLoaded;\n          }\n\n          if (lifecycles.devtools && lifecycles.devtools.overlays) {\n            appBeingLoaded.devtools.overlays = Object.assign(\n              {},\n              app.devtools.overlays,\n              lifecycles.devtools.overlays,\n            );\n          }\n\n          appBeingLoaded.status = AppOrParcelStatus.NOT_INITIALIZED;\n          appBeingLoaded.init = flattenFnArray(lifecycles, \"init\", false);\n          appBeingLoaded.mount = flattenFnArray(lifecycles, \"mount\", false);\n          appBeingLoaded.unmount = flattenFnArray(lifecycles, \"unmount\", false);\n          appBeingLoaded.unload = flattenFnArray(lifecycles, \"unload\", false);\n          appBeingLoaded.timeouts = ensureValidAppTimeouts(lifecycles.timeouts);\n\n          delete appBeingLoaded.loadPromise;\n\n          if (__PROFILE__) {\n            addProfileEntry(\n              \"application\",\n              toName(appBeingLoaded),\n              \"load\",\n              startTime,\n              performance.now(),\n              true,\n            );\n          }\n\n          return appBeingLoaded as LoadedApp;\n        });\n      })\n      .catch((err) => {\n        delete appBeingLoaded.loadPromise;\n\n        let newStatus;\n        if (isUserErr) {\n          newStatus = AppOrParcelStatus.SKIP_BECAUSE_BROKEN;\n        } else {\n          newStatus = AppOrParcelStatus.LOAD_ERROR;\n          appBeingLoaded.loadErrorTime = new Date().getTime();\n        }\n        handleAppError(err, appBeingLoaded, newStatus);\n\n        if (__PROFILE__) {\n          addProfileEntry(\n            \"application\",\n            toName(appBeingLoaded),\n            \"load\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        return appBeingLoaded as LoadedApp;\n      }));\n  });\n}\n","export const isInBrowser = typeof window !== \"undefined\";\n","import { reroute } from \"./reroute\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { isInBrowser } from \"../utils/runtime-environment\";\nimport { StartOpts } from \"../start\";\n\n/* We capture navigation event listeners so that we can make sure\n * that application navigation listeners are not called until\n * single-spa has ensured that the correct applications are\n * unmounted and mounted.\n */\nconst capturedEventListeners: CapturedEventListeners = {\n  hashchange: [],\n  popstate: [],\n};\n\ninterface CapturedEventListeners {\n  hashchange: ((this: Window, ev: HashChangeEvent) => any)[];\n  popstate: ((this: Window, ev: PopStateEvent) => any)[];\n}\n\nexport const routingEventsListeningTo = [\"hashchange\", \"popstate\"];\n\ntype NavigateArg = string | HTMLAnchorElement | MouseEvent;\n\nexport function navigateToUrl(obj: NavigateArg): void {\n  let url;\n  if (typeof obj === \"string\") {\n    url = obj;\n  } else if (this && this.href) {\n    url = this.href;\n  } else if (\n    obj &&\n    \"currentTarget\" in obj &&\n    \"href\" in obj.currentTarget &&\n    \"preventDefault\" in obj\n  ) {\n    url = ((obj as MouseEvent).currentTarget as HTMLAnchorElement).href;\n    (obj as MouseEvent).preventDefault();\n  } else {\n    throw Error(\n      formatErrorMessage(\n        14,\n        __DEV__ &&\n          `singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`,\n      ),\n    );\n  }\n\n  const current = new URL(window.location.href);\n  const destination = new URL(url, window.location.href);\n\n  if (url.indexOf(\"#\") === 0) {\n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    if (process.env.BABEL_ENV === \"test\") {\n      // @ts-expect-error test-only return value\n      return { wouldHaveReloadedThePage: true };\n    } else {\n      window.location.href = url;\n    }\n  } else if (\n    destination.pathname === current.pathname &&\n    destination.search === current.search\n  ) {\n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushState(null, null, url);\n  }\n}\n\nexport function callCapturedEventListeners(\n  eventArguments: [HashChangeEvent | PopStateEvent],\n): void {\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      capturedEventListeners[eventType].forEach((listener) => {\n        try {\n          // The error thrown by application event listener should not break single-spa down.\n          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did\n          listener.apply(this, eventArguments);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\n\nlet urlRerouteOnly: boolean;\n\nfunction urlReroute(evt: HashChangeEvent | PopStateEvent) {\n  reroute([], [evt]);\n}\n\ntype UpdateState = (data: any, unused: string, url?: string | URL) => void;\n\nfunction patchedUpdateState(\n  updateState: UpdateState,\n  methodName: \"pushState\" | \"replaceState\",\n) {\n  return function () {\n    const urlBefore = window.location.href;\n    const result = updateState.apply(this, arguments);\n    const urlAfter = window.location.href;\n\n    if (!urlRerouteOnly || urlBefore !== urlAfter) {\n      // fire an artificial popstate event so that\n      // single-spa applications know about routing that\n      // occurs in a different application\n      window.dispatchEvent(\n        createPopStateEvent(window.history.state, methodName),\n      );\n    }\n\n    return result;\n  };\n}\n\ninterface SingleSpaPopStateEvent extends PopStateEvent {\n  singleSpa: boolean;\n  singleSpaTrigger: string;\n}\n\nfunction createPopStateEvent(\n  state,\n  originalMethodName,\n): SingleSpaPopStateEvent {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn't fire one by default when you call replaceState, so that\n  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and\n  // singleSpaTrigger=<pushState|replaceState> on the event instance.\n  let evt = new PopStateEvent(\"popstate\", { state });\n  (evt as SingleSpaPopStateEvent).singleSpa = true;\n  (evt as SingleSpaPopStateEvent).singleSpaTrigger = originalMethodName;\n  return evt as SingleSpaPopStateEvent;\n}\n\nexport let originalReplaceState: (\n  data: any,\n  unused: string,\n  url?: string | URL,\n) => void = null;\n\nlet historyApiIsPatched: boolean = false;\n\n// We patch the history API so single-spa is notified of all calls to pushState/replaceState.\n// We patch addEventListener/removeEventListener so we can capture all popstate/hashchange event listeners,\n// and delay calling them until single-spa has finished mounting/unmounting applications\nexport function patchHistoryApi(opts?: StartOpts) {\n  if (historyApiIsPatched) {\n    throw Error(\n      formatErrorMessage(\n        43,\n        __DEV__ &&\n          `single-spa: patchHistoryApi() was called after the history api was already patched.`,\n      ),\n    );\n  }\n\n  // True by default, as a performance optimization that reduces\n  // the number of extraneous popstate events\n  urlRerouteOnly = opts?.hasOwnProperty(\"urlRerouteOnly\")\n    ? opts.urlRerouteOnly\n    : true;\n\n  historyApiIsPatched = true;\n\n  originalReplaceState = window.history.replaceState;\n\n  // We will trigger an app change for any routing events.\n  window.addEventListener(\"hashchange\", urlReroute);\n  window.addEventListener(\"popstate\", urlReroute);\n\n  // Patch addEventListener so that we can ensure correct timing\n  const originalAddEventListener = window.addEventListener;\n  const originalRemoveEventListener = window.removeEventListener;\n  window.addEventListener = function (eventName, fn) {\n    if (typeof fn === \"function\") {\n      if (\n        routingEventsListeningTo.indexOf(eventName) >= 0 &&\n        !capturedEventListeners[eventName].find((listener) => listener === fn)\n      ) {\n        capturedEventListeners[eventName].push(fn);\n        return;\n      }\n    }\n\n    return originalAddEventListener.apply(this, arguments);\n  };\n\n  window.removeEventListener = function (eventName, listenerFn) {\n    if (typeof listenerFn === \"function\") {\n      if (routingEventsListeningTo.includes(eventName)) {\n        capturedEventListeners[eventName] = capturedEventListeners[\n          eventName\n        ].filter((fn) => fn !== listenerFn);\n      }\n    }\n\n    return originalRemoveEventListener.apply(this, arguments);\n  };\n\n  window.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    \"pushState\",\n  );\n  window.history.replaceState = patchedUpdateState(\n    originalReplaceState,\n    \"replaceState\",\n  );\n}\n\n// Detect if single-spa has already been loaded on the page.\n// If so, warn because this can result in lots of problems, including\n// lots of extraneous popstate events and unexpected results for\n// apis like getAppNames().\nif (isInBrowser) {\n  if (window.singleSpaNavigate) {\n    console.warn(\n      formatErrorMessage(\n        41,\n        __DEV__ &&\n          \"single-spa has been loaded twice on the page. This can result in unexpected behavior.\",\n      ),\n    );\n  } else {\n    /* For convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag's href is.\n     */\n    window.singleSpaNavigate = navigateToUrl;\n  }\n}\n","import { routingEventsListeningTo } from \"./navigation/navigation-events\";\n\nlet hasInitialized: boolean = false;\n\nexport function ensureJQuerySupport(jQuery: any = window.jQuery): void {\n  if (!jQuery && window?.$?.fn?.jquery) {\n    jQuery = window.$;\n  }\n\n  if (jQuery && !hasInitialized) {\n    const originalJQueryOn = jQuery.fn.on;\n    const originalJQueryOff = jQuery.fn.off;\n\n    jQuery.fn.on = function (eventString, fn) {\n      return captureRoutingEvents.call(\n        this,\n        originalJQueryOn,\n        window.addEventListener,\n        eventString,\n        fn,\n        arguments,\n      );\n    };\n\n    jQuery.fn.off = function (eventString, fn) {\n      return captureRoutingEvents.call(\n        this,\n        originalJQueryOff,\n        window.removeEventListener,\n        eventString,\n        fn,\n        arguments,\n      );\n    };\n\n    hasInitialized = true;\n  }\n}\n\nfunction captureRoutingEvents(\n  originalJQueryFunction: Function,\n  nativeFunctionToCall: Function,\n  eventString: string,\n  fn: Function,\n  originalArgs: any[],\n) {\n  if (typeof eventString !== \"string\") {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n\n  const eventNames = eventString.split(/\\s+/);\n  eventNames.forEach((eventName) => {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n      nativeFunctionToCall(eventName, fn);\n      eventString = eventString.replace(eventName, \"\");\n    }\n  });\n\n  if (eventString.trim() === \"\") {\n    return this;\n  } else {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n}\n\ndeclare global {\n  interface Window {\n    jQuery?: any;\n    $?: any;\n  }\n}\n","import {\n  toName,\n  AppOrParcelStatus,\n  InternalApplication,\n} from \"../applications/app.helpers\";\nimport { handleAppError } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedApp } from \"./lifecycle.helpers\";\n\ninterface UnloadInfo {\n  app: InternalApplication;\n  promise?: Promise<any>;\n  resolve: (val?) => void;\n  reject: (val?) => void;\n}\n\nconst appsToUnload: Record<string, UnloadInfo> = {};\n\nexport function toUnloadPromise(app: LoadedApp): Promise<LoadedApp> {\n  return Promise.resolve().then(() => {\n    const unloadInfo = appsToUnload[toName(app)];\n\n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n       */\n      return app;\n    }\n\n    if (app.status === AppOrParcelStatus.NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(app, unloadInfo);\n      return app;\n    }\n\n    if (app.status === AppOrParcelStatus.UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      return unloadInfo.promise!.then(() => app);\n    }\n\n    if (\n      app.status !== AppOrParcelStatus.NOT_MOUNTED &&\n      app.status !== AppOrParcelStatus.LOAD_ERROR &&\n      app.status !== AppOrParcelStatus.SKIP_BECAUSE_BROKEN\n    ) {\n      /* The app cannot be unloaded unless in certain statuses\n       */\n      return app;\n    }\n\n    let startTime: number;\n\n    if (__PROFILE__) {\n      startTime = performance.now();\n    }\n\n    const unloadPromise = app.unload\n      ? reasonableTime(app, \"unload\")\n      : Promise.resolve();\n\n    app.status = AppOrParcelStatus.UNLOADING;\n\n    return unloadPromise\n      .then(() => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            \"application\",\n            toName(app),\n            \"unload\",\n            startTime,\n            performance.now(),\n            true,\n          );\n        }\n\n        finishUnloadingApp(app, unloadInfo);\n\n        return app;\n      })\n      .catch((err) => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            \"application\",\n            toName(app),\n            \"unload\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        errorUnloadingApp(app, unloadInfo, err);\n\n        return app;\n      });\n  });\n}\n\nfunction finishUnloadingApp(app: LoadedApp, unloadInfo: UnloadInfo) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don't have lifecycles\n  delete app.init;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  app.status = AppOrParcelStatus.NOT_LOADED;\n\n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app: LoadedApp, unloadInfo: UnloadInfo, err: Error) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don't have lifecycles\n  delete app.init;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleAppError(err, app, AppOrParcelStatus.SKIP_BECAUSE_BROKEN);\n  unloadInfo.reject(err);\n}\n\nexport function addAppToUnload(\n  app: InternalApplication,\n  promiseGetter: () => Promise<any>,\n  resolve: (val?) => any,\n  reject: (val?) => any,\n) {\n  appsToUnload[toName(app)] = { app, resolve, reject };\n  Object.defineProperty(appsToUnload[toName(app)], \"promise\", {\n    get: promiseGetter,\n  });\n}\n\nexport function getAppUnloadInfo(appName: string): UnloadInfo {\n  return appsToUnload[appName];\n}\n","import { ensureJQuerySupport } from \"../jquery-support\";\nimport {\n  isActive,\n  toName,\n  shouldBeActive,\n  InternalApplication,\n  AppOrParcelStatus,\n} from \"./app.helpers\";\nimport { reroute, triggerAppChange } from \"../navigation/reroute\";\nimport { toUnmountPromise } from \"../lifecycles/unmount\";\nimport {\n  toUnloadPromise,\n  getAppUnloadInfo,\n  addAppToUnload,\n} from \"../lifecycles/unload\";\nimport { formatErrorMessage } from \"./app-errors\";\nimport { isInBrowser } from \"../utils/runtime-environment\";\nimport { isStarted } from \"../start\";\nimport {\n  Activity,\n  ActivityFn,\n  AppProps,\n  Application,\n  CustomProps,\n  CustomPropsFn,\n  LifeCycles,\n  LoadApp,\n  LoadedApp,\n  RegisterApplicationConfig,\n  SingleSpaLocation,\n} from \"../lifecycles/lifecycle.helpers\";\n\nconst apps: InternalApplication[] = [];\n\ninterface AppChanges {\n  appsToUnload: InternalApplication[];\n  appsToUnmount: InternalApplication[];\n  appsToLoad: InternalApplication[];\n  appsToMount: InternalApplication[];\n}\n\nexport function getAppChanges(): AppChanges {\n  const appsToUnload: InternalApplication[] = [],\n    appsToUnmount: InternalApplication[] = [],\n    appsToLoad: InternalApplication[] = [],\n    appsToMount: InternalApplication[] = [];\n\n  // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds\n  const currentTime: number = new Date().getTime();\n\n  apps.forEach((app) => {\n    const appShouldBeActive =\n      app.status !== AppOrParcelStatus.SKIP_BECAUSE_BROKEN &&\n      shouldBeActive(app);\n\n    switch (app.status) {\n      case AppOrParcelStatus.LOAD_ERROR:\n        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n          appsToLoad.push(app);\n        }\n        break;\n      case AppOrParcelStatus.NOT_LOADED:\n      case AppOrParcelStatus.LOADING_SOURCE_CODE:\n        if (appShouldBeActive) {\n          appsToLoad.push(app);\n        }\n        break;\n      case AppOrParcelStatus.NOT_INITIALIZED:\n      case AppOrParcelStatus.NOT_MOUNTED:\n        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n          appsToUnload.push(app);\n        } else if (appShouldBeActive) {\n          appsToMount.push(app);\n        }\n        break;\n      case AppOrParcelStatus.MOUNTED:\n        if (!appShouldBeActive) {\n          appsToUnmount.push(app);\n        }\n        break;\n      // all other statuses are ignored\n    }\n  });\n\n  return { appsToUnload, appsToUnmount, appsToLoad, appsToMount };\n}\n\nexport function getMountedApps(): string[] {\n  return apps.filter(isActive).map(toName);\n}\n\nexport function getAppNames(): string[] {\n  return apps.map(toName);\n}\n\n// used in devtools, not (currently) exposed as a single-spa API\nexport function getRawAppData(): InternalApplication[] {\n  return [...apps];\n}\n\nexport function getAppStatus(appName): AppOrParcelStatus | null {\n  const app = apps.find((app) => toName(app) === appName);\n  return app ? app.status : null;\n}\n\nlet startWarningInitialized: boolean = false;\n\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n  RegisterApplicationConfig,\n): void;\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n  appName: string,\n  app: Application,\n  activeWhen: Activity,\n  customProps: ExtraProps | CustomPropsFn<ExtraProps>,\n): void;\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n  appNameOrConfig: string | RegisterApplicationConfig,\n  appOrLoadApp?: Application,\n  activeWhen?: Activity,\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>,\n): void {\n  const registration = sanitizeArguments(\n    appNameOrConfig,\n    appOrLoadApp,\n    activeWhen,\n    customProps,\n  );\n\n  if (!isStarted() && !startWarningInitialized) {\n    startWarningInitialized = true;\n\n    setTimeout(() => {\n      if (!isStarted()) {\n        console.warn(\n          formatErrorMessage(\n            1,\n            __DEV__ &&\n              `singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not initialized or mounted.`,\n          ),\n        );\n      }\n    }, 5000);\n  }\n\n  if (getAppNames().indexOf(registration.name) !== -1)\n    throw Error(\n      formatErrorMessage(\n        21,\n        __DEV__ &&\n          `There is already an app registered with name ${registration.name}`,\n        registration.name,\n      ),\n    );\n\n  apps.push(\n    Object.assign(\n      {\n        loadErrorTime: null,\n        status: AppOrParcelStatus.NOT_LOADED,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      registration,\n    ),\n  );\n\n  if (isInBrowser) {\n    ensureJQuerySupport();\n    reroute();\n  }\n}\n\nexport function checkActivityFunctions(\n  location: SingleSpaLocation = window.location,\n): string[] {\n  return apps.filter((app) => app.activeWhen(location)).map(toName);\n}\n\nexport function unregisterApplication(appName: string): Promise<void> {\n  if (apps.filter((app) => toName(app) === appName).length === 0) {\n    throw Error(\n      formatErrorMessage(\n        25,\n        __DEV__ &&\n          `Cannot unregister application '${appName}' because no such application has been registered`,\n        appName,\n      ),\n    );\n  }\n\n  const unloadPromise = isInBrowser\n    ? // See https://github.com/single-spa/single-spa/issues/871 for why waitForUnmount is false\n      unloadApplication(appName, { waitForUnmount: false })\n    : Promise.resolve();\n\n  return unloadPromise.then(() => {\n    const appIndex = apps.map(toName).indexOf(appName);\n    apps.splice(appIndex, 1);\n  });\n}\n\nexport function unloadApplication(\n  appName: string,\n  opts: { waitForUnmount: boolean } = { waitForUnmount: false },\n): Promise<void> {\n  if (typeof appName !== \"string\") {\n    throw Error(\n      formatErrorMessage(\n        26,\n        __DEV__ && `unloadApplication requires a string 'appName'`,\n      ),\n    );\n  }\n  const app = apps.find((app) => toName(app) === appName);\n  if (!app) {\n    throw Error(\n      formatErrorMessage(\n        27,\n        __DEV__ &&\n          `Could not unload application '${appName}' because no such application has been registered`,\n        appName,\n      ),\n    );\n  }\n\n  const appUnloadInfo = getAppUnloadInfo(toName(app));\n  if (opts?.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      return appUnloadInfo.promise;\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      const promise = new Promise<void>((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.\n     */\n\n    let resultPromise;\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n\n    return resultPromise;\n  }\n}\n\nfunction immediatelyUnloadApp(\n  app: InternalApplication,\n  resolve: (value?: any) => void,\n  reject: (value?: any) => void,\n): void {\n  Promise.resolve()\n    .then(() => {\n      // Before unmounting the application, we first must wait for it to finish mounting\n      // Otherwise, the test for issue 871 in unregister-application.spec.js fails because\n      // the application isn't really unmounted.\n      if (\n        checkActivityFunctions().find((activeApp) => activeApp === toName(app))\n      ) {\n        return triggerAppChange();\n      }\n    })\n    .then(() => {\n      return toUnmountPromise(app as LoadedApp)\n        .then(toUnloadPromise)\n        .then(() => {\n          resolve();\n          setTimeout(() => {\n            // reroute, but the unload promise is done\n            reroute();\n          });\n        });\n    })\n    .catch(reject);\n}\n\nfunction validateRegisterWithArguments(\n  name: string,\n  appOrLoadApp: Application,\n  activeWhen: Activity,\n  customProps?: CustomProps | CustomPropsFn,\n): void {\n  if (typeof name !== \"string\" || name.length === 0)\n    throw Error(\n      formatErrorMessage(\n        20,\n        __DEV__ &&\n          `The 1st argument to registerApplication must be a non-empty string 'appName'`,\n      ),\n    );\n\n  if (!appOrLoadApp)\n    throw Error(\n      formatErrorMessage(\n        23,\n        __DEV__ &&\n          \"The 2nd argument to registerApplication must be an application or loading application function\",\n      ),\n    );\n\n  if (typeof activeWhen !== \"function\")\n    throw Error(\n      formatErrorMessage(\n        24,\n        __DEV__ &&\n          \"The 3rd argument to registerApplication must be an activeWhen function\",\n      ),\n    );\n\n  if (!validCustomProps(customProps))\n    throw Error(\n      formatErrorMessage(\n        22,\n        __DEV__ &&\n          \"The optional 4th argument is a customProps and must be an object\",\n      ),\n    );\n}\n\nexport function validateRegisterWithConfig(\n  config: Partial<RegisterApplicationConfig>,\n): void {\n  if (Array.isArray(config) || config === null)\n    throw Error(\n      formatErrorMessage(\n        39,\n        __DEV__ && \"Configuration object can't be an Array or null!\",\n      ),\n    );\n  const validKeys = [\"name\", \"app\", \"activeWhen\", \"customProps\"];\n  const invalidKeys = Object.keys(config).reduce(\n    (invalidKeys, prop) =>\n      validKeys.indexOf(prop) >= 0 ? invalidKeys : invalidKeys.concat(prop),\n    [],\n  );\n  if (invalidKeys.length !== 0)\n    throw Error(\n      formatErrorMessage(\n        38,\n        __DEV__ &&\n          `The configuration object accepts only: ${validKeys.join(\n            \", \",\n          )}. Invalid keys: ${invalidKeys.join(\", \")}.`,\n        validKeys.join(\", \"),\n        invalidKeys.join(\", \"),\n      ),\n    );\n  if (typeof config.name !== \"string\" || config.name.length === 0)\n    throw Error(\n      formatErrorMessage(\n        20,\n        __DEV__ &&\n          \"The config.name on registerApplication must be a non-empty string\",\n      ),\n    );\n  if (typeof config.app !== \"object\" && typeof config.app !== \"function\")\n    throw Error(\n      formatErrorMessage(\n        20,\n        __DEV__ &&\n          \"The config.app on registerApplication must be an application or a loading function\",\n      ),\n    );\n  const allowsStringAndFunction = (activeWhen) =>\n    typeof activeWhen === \"string\" || typeof activeWhen === \"function\";\n  if (\n    !allowsStringAndFunction(config.activeWhen) &&\n    !(\n      Array.isArray(config.activeWhen) &&\n      config.activeWhen.every(allowsStringAndFunction)\n    )\n  )\n    throw Error(\n      formatErrorMessage(\n        24,\n        __DEV__ &&\n          \"The config.activeWhen on registerApplication must be a string, function or an array with both\",\n      ),\n    );\n  if (!validCustomProps(config.customProps))\n    throw Error(\n      formatErrorMessage(\n        22,\n        __DEV__ && \"The optional config.customProps must be an object\",\n      ),\n    );\n}\n\nfunction validCustomProps(customProps: unknown): boolean {\n  return (\n    !customProps ||\n    typeof customProps === \"function\" ||\n    (typeof customProps === \"object\" &&\n      customProps !== null &&\n      !Array.isArray(customProps))\n  );\n}\n\ninterface ApplicationRegistration {\n  name: string;\n  loadApp: LoadApp;\n  activeWhen: ActivityFn;\n  customProps?: CustomProps;\n}\n\nfunction sanitizeArguments<ExtraProps extends CustomProps = {}>(\n  appNameOrConfig: string | RegisterApplicationConfig,\n  appOrLoadApp: Application,\n  activeWhen: Activity,\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>,\n): ApplicationRegistration {\n  const usingObjectAPI = typeof appNameOrConfig === \"object\";\n\n  let unsanitizedRegistration: {\n    name: string;\n    app: Application;\n    activeWhen: Activity;\n    customProps: CustomProps | CustomPropsFn<CustomProps>;\n  };\n\n  if (usingObjectAPI) {\n    validateRegisterWithConfig(appNameOrConfig);\n    unsanitizedRegistration = {\n      name: appNameOrConfig.name,\n      app: appNameOrConfig.app,\n      activeWhen: appNameOrConfig.activeWhen,\n      customProps: appNameOrConfig.customProps,\n    };\n  } else {\n    validateRegisterWithArguments(\n      appNameOrConfig,\n      appOrLoadApp,\n      activeWhen,\n      customProps,\n    );\n    unsanitizedRegistration = {\n      name: appNameOrConfig,\n      app: appOrLoadApp,\n      activeWhen,\n      customProps,\n    };\n  }\n\n  return {\n    name: unsanitizedRegistration.name,\n    loadApp: sanitizeLoadApp(unsanitizedRegistration.app),\n    customProps: sanitizeCustomProps(unsanitizedRegistration.customProps),\n    activeWhen: sanitizeActiveWhen(unsanitizedRegistration.activeWhen),\n  };\n}\n\nfunction sanitizeLoadApp<ExtraProps extends CustomProps = {}>(\n  loadApp: Application,\n): (config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>> {\n  if (typeof loadApp !== \"function\") {\n    return () => Promise.resolve(loadApp);\n  }\n\n  return loadApp;\n}\n\nfunction sanitizeCustomProps(customProps?: CustomProps): CustomProps {\n  return customProps ? customProps : {};\n}\n\nfunction sanitizeActiveWhen(activeWhen: Activity): ActivityFn {\n  const activeWhenArray: (ActivityFn | string)[] = Array.isArray(activeWhen)\n    ? activeWhen\n    : [activeWhen];\n  const activityFnArray: ActivityFn[] = activeWhenArray.map(\n    (activeWhenOrPath) =>\n      typeof activeWhenOrPath === \"function\"\n        ? activeWhenOrPath\n        : pathToActiveWhen(activeWhenOrPath, false),\n  );\n\n  return (location) =>\n    activityFnArray.some((activeWhen) => activeWhen(location));\n}\n\nexport function pathToActiveWhen(\n  path: string,\n  exactMatch?: boolean,\n): ActivityFn {\n  const regex = toDynamicPathValidatorRegex(path, exactMatch);\n\n  return (location: Location) => {\n    const route = location.href\n      .replace(location.origin, \"\")\n      .replace(location.search, \"\")\n      .split(\"?\")[0];\n    return regex.test(route);\n  };\n}\n\nfunction toDynamicPathValidatorRegex(path: string, exactMatch?: boolean) {\n  let lastIndex: number = 0,\n    inDynamic: boolean = false,\n    regexStr: string = \"^\";\n\n  if (path[0] !== \"/\") {\n    path = \"/\" + path;\n  }\n\n  for (let charIndex = 0; charIndex < path.length; charIndex++) {\n    const char = path[charIndex];\n    const startOfDynamic = !inDynamic && char === \":\";\n    const endOfDynamic = inDynamic && char === \"/\";\n    if (startOfDynamic || endOfDynamic) {\n      appendToRegex(charIndex);\n    }\n  }\n\n  appendToRegex(path.length);\n  return new RegExp(regexStr, \"i\");\n\n  function appendToRegex(index) {\n    const anyCharMaybeTrailingSlashRegex = \"[^/]+/?\";\n    const commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));\n\n    regexStr += inDynamic\n      ? anyCharMaybeTrailingSlashRegex\n      : commonStringSubPath;\n\n    if (index === path.length) {\n      if (inDynamic) {\n        if (exactMatch) {\n          // Ensure exact match paths that end in a dynamic portion don't match\n          // urls with characters after a slash after the dynamic portion.\n          regexStr += \"$\";\n        }\n      } else {\n        // For exact matches, expect no more characters. Otherwise, allow\n        // any characters.\n        const suffix = exactMatch ? \"\" : \".*\";\n\n        regexStr =\n          // use charAt instead as we could not use es6 method endsWith\n          regexStr.charAt(regexStr.length - 1) === \"/\"\n            ? `${regexStr}${suffix}$`\n            : `${regexStr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    inDynamic = !inDynamic;\n    lastIndex = index;\n  }\n\n  function escapeStrRegex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n  }\n}\n","import { isStarted } from \"../start\";\nimport { toLoadPromise } from \"../lifecycles/load\";\nimport { toInitPromise } from \"../lifecycles/init\";\nimport { toMountPromise } from \"../lifecycles/mount\";\nimport { toUnmountPromise } from \"../lifecycles/unmount\";\nimport {\n  getAppStatus,\n  getAppChanges,\n  getMountedApps,\n} from \"../applications/apps\";\nimport {\n  callCapturedEventListeners,\n  originalReplaceState,\n} from \"./navigation-events\";\nimport { toUnloadPromise } from \"../lifecycles/unload\";\nimport {\n  toName,\n  shouldBeActive,\n  AppOrParcelStatus,\n  InternalApplication,\n} from \"../applications/app.helpers\";\nimport { isInBrowser } from \"../utils/runtime-environment\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedApp } from \"../lifecycles/lifecycle.helpers\";\n\ntype EventArguments = [HashChangeEvent | PopStateEvent];\n\ninterface WaitingPromises {\n  resolve(value: unknown): void;\n  reject(value: unknown): void;\n  eventArguments?: [HashChangeEvent | PopStateEvent];\n}\n\nlet appChangeUnderway: boolean = false,\n  promisesWaitingOnAppChange: WaitingPromises[] = [],\n  currentUrl = isInBrowser && window.location.href;\n\nexport function triggerAppChange() {\n  // Call reroute with no arguments, intentionally\n  return reroute();\n}\n\nexport function reroute(\n  pendingPromises: WaitingPromises[] = [],\n  eventArguments: EventArguments = undefined,\n  silentNavigation: boolean = false,\n): Promise<string[]> {\n  if (appChangeUnderway) {\n    return new Promise((resolve, reject) => {\n      promisesWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n\n  let startTime: number, profilerKind: ProfileEntry[\"kind\"];\n\n  if (__PROFILE__) {\n    startTime = performance.now();\n    if (silentNavigation) {\n      profilerKind = \"silentNavigation\";\n    } else if (eventArguments) {\n      profilerKind = \"browserNavigation\";\n    } else {\n      profilerKind = \"triggerAppChange\";\n    }\n  }\n\n  const { appsToUnload, appsToUnmount, appsToLoad, appsToMount } =\n    getAppChanges();\n  let appsThatChanged: InternalApplication[],\n    cancelPromises: Promise<unknown>[] = [],\n    oldUrl: string = currentUrl,\n    newUrl: string = (currentUrl = window.location.href);\n\n  if (isStarted()) {\n    appChangeUnderway = true;\n    appsThatChanged = appsToUnload.concat(\n      appsToLoad,\n      appsToUnmount,\n      appsToMount,\n    );\n    return performAppChanges();\n  } else {\n    appsThatChanged = appsToLoad;\n    return loadApps();\n  }\n\n  function cancelNavigation(val: boolean | Promise<boolean> = true) {\n    const promise: Promise<boolean> =\n      typeof (val as Promise<boolean>)?.then === \"function\"\n        ? (val as Promise<boolean>)\n        : Promise.resolve(val);\n    cancelPromises.push(\n      promise.catch((err) => {\n        console.warn(\n          Error(\n            formatErrorMessage(\n              42,\n              __DEV__ &&\n                `single-spa: A cancelNavigation promise rejected with the following value: ${err}`,\n            ),\n          ),\n        );\n        console.warn(err);\n\n        // Interpret a Promise rejection to mean that the navigation should not be canceled\n        return false;\n      }),\n    );\n  }\n\n  function loadApps(): Promise<string[]> {\n    return Promise.resolve().then(() => {\n      const loadPromises = appsToLoad.map(toLoadPromise);\n      let succeeded: boolean;\n\n      return (\n        Promise.all(loadPromises)\n          .then(callAllEventListeners)\n          // there are no mounted apps, before start() is called, so we always return []\n          .then(() => {\n            if (__PROFILE__) {\n              succeeded = true;\n            }\n\n            return [];\n          })\n          .catch((err) => {\n            if (__PROFILE__) {\n              succeeded = false;\n            }\n\n            callAllEventListeners();\n            throw err;\n          })\n          .finally(() => {\n            if (__PROFILE__) {\n              addProfileEntry(\n                \"routing\",\n                \"loadApps\",\n                profilerKind,\n                startTime,\n                performance.now(),\n                succeeded,\n              );\n            }\n          })\n      );\n    });\n  }\n\n  function performAppChanges(): Promise<string[]> {\n    return Promise.resolve().then(() => {\n      // https://github.com/single-spa/single-spa/issues/545\n      fireSingleSpaEvent(\n        appsThatChanged.length === 0\n          ? \"before-no-app-change\"\n          : \"before-app-change\",\n        getCustomEventDetail(true),\n      );\n\n      fireSingleSpaEvent(\n        \"before-routing-event\",\n        getCustomEventDetail(true, { cancelNavigation }),\n      );\n\n      return Promise.all(cancelPromises).then((cancelValues) => {\n        const navigationIsCanceled: boolean = cancelValues.some((v) => v);\n\n        if (navigationIsCanceled) {\n          // Change url back to old url, without triggering the normal single-spa reroute\n          originalReplaceState.call(\n            window.history,\n            history.state,\n            \"\",\n            oldUrl.substring(location.origin.length),\n          );\n\n          // Single-spa's internal tracking of current url needs to be updated after the url change above\n          currentUrl = location.href;\n\n          // necessary for the reroute function to know that the current reroute is finished\n          appChangeUnderway = false;\n\n          if (__PROFILE__) {\n            addProfileEntry(\n              \"routing\",\n              \"navigationCanceled\",\n              profilerKind,\n              startTime,\n              performance.now(),\n              true,\n            );\n          }\n\n          // Tell single-spa to reroute again, this time with the url set to the old URL\n          return reroute(pendingPromises, eventArguments, true);\n        }\n\n        const unloadPromises: Promise<InternalApplication>[] =\n          appsToUnload.map(toUnloadPromise);\n\n        const unmountUnloadPromises = (appsToUnmount as LoadedApp[])\n          .map((app) => toUnmountPromise(app))\n          .map((unmountPromise: Promise<LoadedApp>) =>\n            unmountPromise.then(toUnloadPromise),\n          );\n\n        const allUnmountPromises: Promise<InternalApplication>[] = [\n          ...unmountUnloadPromises,\n          ...unloadPromises,\n        ];\n\n        const unmountAllPromise = Promise.all(allUnmountPromises);\n\n        let unmountFinishedTime: number;\n\n        unmountAllPromise.then(\n          () => {\n            if (__PROFILE__) {\n              unmountFinishedTime = performance.now();\n\n              addProfileEntry(\n                \"routing\",\n                \"unmountAndUnload\",\n                profilerKind,\n                startTime,\n                performance.now(),\n                true,\n              );\n            }\n            fireSingleSpaEvent(\n              \"before-mount-routing-event\",\n              getCustomEventDetail(true),\n            );\n          },\n          (err) => {\n            if (__PROFILE__) {\n              addProfileEntry(\n                \"routing\",\n                \"unmountAndUnload\",\n                profilerKind,\n                startTime,\n                performance.now(),\n                true,\n              );\n            }\n\n            throw err;\n          },\n        );\n\n        /* We load and init apps while other apps are unmounting, but we\n         * wait to mount the app until all apps are finishing unmounting\n         */\n        const loadThenMountPromises: Promise<InternalApplication>[] =\n          appsToLoad.map((app) => {\n            return toLoadPromise(app).then((app) =>\n              tryToInitAndMount(app, unmountAllPromise),\n            );\n          });\n\n        /* These are the apps that are already initialized and just need\n         * to be mounted. They each wait for all unmounting apps to finish up\n         * before they mount.\n         */\n        const mountPromises: Promise<InternalApplication>[] = appsToMount\n          .filter((appToMount) => !appsToLoad.includes(appToMount))\n          .map((appToMount) => {\n            return tryToInitAndMount(appToMount, unmountAllPromise);\n          });\n        return unmountAllPromise\n          .catch((err) => {\n            callAllEventListeners();\n            throw err;\n          })\n          .then(() => {\n            /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n             * events (like hashchange or popstate) should have been cleaned up. So it's safe\n             * to let the remaining captured event listeners to handle about the DOM event.\n             */\n            callAllEventListeners();\n\n            return Promise.all(loadThenMountPromises.concat(mountPromises))\n              .catch((err) => {\n                pendingPromises.forEach((promise) => promise.reject(err));\n                throw err;\n              })\n              .then(\n                () => {\n                  if (__PROFILE__) {\n                    addProfileEntry(\n                      \"routing\",\n                      \"loadAndMount\",\n                      profilerKind,\n                      unmountFinishedTime,\n                      performance.now(),\n                      true,\n                    );\n                  }\n                },\n                (err) => {\n                  if (__PROFILE__) {\n                    addProfileEntry(\n                      \"routing\",\n                      \"loadAndMount\",\n                      profilerKind,\n                      unmountFinishedTime,\n                      performance.now(),\n                      false,\n                    );\n                  }\n\n                  throw err;\n                },\n              )\n              .then(finishUpAndReturn);\n          });\n      });\n    });\n  }\n\n  function finishUpAndReturn(): string[] {\n    const returnValue = getMountedApps();\n    pendingPromises.forEach((promise) => promise.resolve(returnValue));\n\n    try {\n      const appChangeEventName =\n        appsThatChanged.length === 0 ? \"no-app-change\" : \"app-change\";\n      fireSingleSpaEvent(appChangeEventName, getCustomEventDetail());\n      fireSingleSpaEvent(\"routing-event\", getCustomEventDetail());\n    } catch (err) {\n      /* We use a setTimeout because if someone else's event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it's their own fault, not\n       * single-spa's.\n       */\n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    appChangeUnderway = false;\n\n    if (promisesWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      const nextPendingPromises = promisesWaitingOnAppChange;\n      promisesWaitingOnAppChange = [];\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n\n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  function callAllEventListeners() {\n    // During silent navigation (when navigation was canceled and we're going back to the old URL),\n    // we should not fire any popstate / hashchange events\n    if (!silentNavigation) {\n      pendingPromises.forEach((pendingPromise) => {\n        callCapturedEventListeners(pendingPromise.eventArguments);\n      });\n\n      callCapturedEventListeners(eventArguments);\n    }\n  }\n\n  function getCustomEventDetail(\n    isBeforeChanges: boolean = false,\n    extraProperties?: Object,\n  ): CustomEventInit {\n    const newAppStatuses = {};\n    const appsByNewStatus = {\n      // for apps that were mounted\n      [AppOrParcelStatus.MOUNTED]: [],\n      // for apps that were unmounted\n      [AppOrParcelStatus.NOT_MOUNTED]: [],\n      // apps that were forcibly unloaded\n      [AppOrParcelStatus.NOT_LOADED]: [],\n      // apps that attempted to do something but are broken now\n      [AppOrParcelStatus.SKIP_BECAUSE_BROKEN]: [],\n    };\n\n    if (isBeforeChanges) {\n      appsToLoad.concat(appsToMount).forEach((app, index) => {\n        addApp(app, AppOrParcelStatus.MOUNTED);\n      });\n      appsToUnload.forEach((app) => {\n        addApp(app, AppOrParcelStatus.NOT_LOADED);\n      });\n      appsToUnmount.forEach((app) => {\n        addApp(app, AppOrParcelStatus.NOT_MOUNTED);\n      });\n    } else {\n      appsThatChanged.forEach((app) => {\n        addApp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newAppStatuses,\n        appsByNewStatus,\n        totalAppChanges: appsThatChanged.length,\n        originalEvent: eventArguments?.[0],\n        oldUrl,\n        newUrl,\n      },\n    };\n\n    if (extraProperties) {\n      Object.assign(result.detail, extraProperties);\n    }\n\n    return result;\n\n    function addApp(\n      app: InternalApplication,\n      status?: InternalApplication[\"status\"],\n    ) {\n      const appName = toName(app);\n      status = status || getAppStatus(appName);\n      newAppStatuses[appName] = status;\n      const statusArr = (appsByNewStatus[status] =\n        appsByNewStatus[status] || []);\n      statusArr.push(appName);\n    }\n  }\n\n  function fireSingleSpaEvent(name: string, eventProperties: CustomEventInit) {\n    // During silent navigation (caused by navigation cancelation), we should not\n    // fire any single-spa events\n    if (!silentNavigation) {\n      window.dispatchEvent(\n        new CustomEvent(`single-spa:${name}`, eventProperties),\n      );\n    }\n  }\n}\n\n/**\n * Let's imagine that some kind of delay occurred during application loading.\n * The user without waiting for the application to load switched to another route,\n * this means that we shouldn't initialize and mount that application, thus we check\n * twice if that application should be active before initialize and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */\nfunction tryToInitAndMount(\n  app: InternalApplication,\n  unmountAllPromise: Promise<unknown>,\n): Promise<InternalApplication> {\n  if (shouldBeActive(app)) {\n    return toInitPromise(app as LoadedApp).then((app) =>\n      unmountAllPromise.then(() =>\n        shouldBeActive(app) ? toMountPromise(app) : app,\n      ),\n    ) as Promise<InternalApplication>;\n  } else {\n    return unmountAllPromise.then(() => app);\n  }\n}\n","import { reroute } from \"./navigation/reroute\";\nimport { patchHistoryApi } from \"./navigation/navigation-events\";\nimport { isInBrowser } from \"./utils/runtime-environment\";\n\nlet started: boolean = false;\n\nexport function start(opts?: StartOpts) {\n  started = true;\n  if (isInBrowser) {\n    patchHistoryApi(opts);\n    reroute();\n  }\n}\n\nexport function isStarted(): boolean {\n  return started;\n}\n\nexport interface StartOpts {\n  urlRerouteOnly?: boolean;\n}\n","import { getRawAppData, unregisterApplication } from \"../applications/apps\";\nimport { reroute } from \"../navigation/reroute\";\nimport { AppOrParcelStatus } from \"../applications/app.helpers\";\nimport { toLoadPromise } from \"../lifecycles/load\";\nimport { toInitPromise } from \"../lifecycles/init\";\nimport { getProfilerData } from \"./profiler\";\n\nexport default {\n  getRawAppData,\n  reroute,\n  NOT_LOADED: AppOrParcelStatus.NOT_LOADED,\n  toLoadPromise,\n  toBootstrapPromise: toInitPromise,\n  unregisterApplication,\n  getProfilerData,\n};\n","export { start } from \"./start\";\nexport type { StartOpts } from \"./start\";\nexport { ensureJQuerySupport } from \"./jquery-support\";\nexport {\n  setInitMaxTime,\n  setMountMaxTime,\n  setUnmountMaxTime,\n  setUnloadMaxTime,\n} from \"./applications/timeouts\";\nexport {\n  registerApplication,\n  unregisterApplication,\n  getMountedApps,\n  getAppStatus,\n  unloadApplication,\n  checkActivityFunctions,\n  getAppNames,\n  pathToActiveWhen,\n} from \"./applications/apps\";\nexport { navigateToUrl, patchHistoryApi } from \"./navigation/navigation-events\";\nexport { triggerAppChange } from \"./navigation/reroute\";\nexport {\n  addErrorHandler,\n  removeErrorHandler,\n  type SingleSpaError,\n  type ErrorHandler,\n} from \"./applications/app-errors\";\nexport { mountRootParcel } from \"./parcels/mount-parcel\";\nexport type {\n  CustomProps,\n  ParcelCustomProps,\n  CustomPropsFn,\n  AppProps,\n  ParcelConfig,\n  ParcelConfigObject,\n  LifeCycles,\n  LifeCycleFn,\n  Parcel,\n  Application,\n  LoadApp,\n  ActivityFn,\n  Activity,\n  RegisterApplicationConfig,\n} from \"./lifecycles/lifecycle.helpers\";\n\nexport { AppOrParcelStatus } from \"./applications/app.helpers\";\n\nimport devtools from \"./devtools/devtools\";\nimport { isInBrowser } from \"./utils/runtime-environment\";\n\nif (isInBrowser && window.__SINGLE_SPA_DEVTOOLS__) {\n  window.__SINGLE_SPA_DEVTOOLS__.exposedMethods = devtools;\n}\n\ndeclare global {\n  interface Window {\n    __SINGLE_SPA_DEVTOOLS__: {\n      exposedMethods: typeof devtools;\n    };\n  }\n}\n"],"names":["errorHandlers","handleAppError","err","app","newStatus","transformedErr","transformErr","length","forEach","handler","setTimeout","addErrorHandler","Error","formatErrorMessage","push","removeErrorHandler","removedSomething","filter","h","isHandler","code","msg","args","join","ogErr","appOrParcel","errPrefix","objectType","toName","status","result","message","console","warn","JSON","stringify","singleSpaErr","appOrParcelName","AppOrParcelStatus","isActive","MOUNTED","shouldBeActive","activeWhen","window","location","SKIP_BECAUSE_BROKEN","name","isParcel","Boolean","unmountThisParcel","validLifecycleFn","fn","arr","Array","isArray","find","item","flattenFnArray","lifecycle","fns","Promise","resolve","type","props","reduce","resultPromise","index","then","thisPromise","smellsLikeAPromise","reject","promise","catch","profileEntries","toInitPromise","hardFail","NOT_INITIALIZED","INITIALIZING","reasonableTime","successfulInit","NOT_MOUNTED","toUnmountPromise","UNMOUNTING","unmountChildrenParcels","Object","keys","parcels","map","parcelId","all","unmountAppOrParcel","parcelError","parentError","beforeFirstMountFired","firstMountFired","toMountPromise","dispatchEvent","CustomEvent","MOUNTING","setSkipBecauseBroken","parcelCount","rootParcels","mountRootParcel","config","customProps","mountParcel","call","owningAppOrParcel","this","id","domElement","passedConfigLoadingFunction","configLoadingFunction","parcel","LOADING_SOURCE_CODE","parentName","currentTask","undefined","value","resolveUnmount","rejectUnmount","loadPromise","prototype","hasOwnProperty","init","mount","unmount","update","timeouts","ensureValidAppTimeouts","fullParcel","initPromise","mountPromise","unmountPromise","externalRepresentation","promiseWithoutReturnValue","getStatus","_parcel","UPDATING","getProps","assign","bind","unmountSelf","defaultWarningMillis","globalTimeoutConfig","millis","dieOnTimeout","warningMillis","unload","setInitMaxTime","time","setMountMaxTime","setUnmountMaxTime","setUnloadMaxTime","timeoutConfig","warningPeriod","finished","errored","val","maybeTimingOut","errMsg","shouldError","error","numWarnings","numMillis","key","_a","toLoadPromise","NOT_LOADED","LOAD_ERROR","appBeingLoaded","lifecycles","isUserErr","loadApp","validationErrCode","loadErrorTime","appOptsStr","validationErrMessage","devtools","overlays","Date","getTime","isInBrowser","capturedEventListeners","hashchange","popstate","routingEventsListeningTo","navigateToUrl","obj","url","href","currentTarget","preventDefault","current","URL","destination","indexOf","hash","host","pathname","search","history","pushState","callCapturedEventListeners","eventArguments","eventType","listener","apply","e","urlRerouteOnly","urlReroute","evt","reroute","patchedUpdateState","updateState","methodName","urlBefore","arguments","urlAfter","state","originalMethodName","PopStateEvent","singleSpa","singleSpaTrigger","createPopStateEvent","originalReplaceState","historyApiIsPatched","patchHistoryApi","opts","replaceState","addEventListener","originalAddEventListener","originalRemoveEventListener","removeEventListener","eventName","listenerFn","includes","singleSpaNavigate","hasInitialized","ensureJQuerySupport","jQuery","$","jquery","originalJQueryOn","on","originalJQueryOff","off","eventString","captureRoutingEvents","originalJQueryFunction","nativeFunctionToCall","originalArgs","split","replace","trim","appsToUnload","toUnloadPromise","unloadInfo","finishUnloadingApp","UNLOADING","unloadPromise","errorUnloadingApp","addAppToUnload","promiseGetter","defineProperty","get","getAppUnloadInfo","appName","apps","getMountedApps","getAppNames","getAppStatus","startWarningInitialized","registerApplication","appNameOrConfig","appOrLoadApp","registration","unsanitizedRegistration","validKeys","invalidKeys","prop","concat","allowsStringAndFunction","every","validCustomProps","validateRegisterWithConfig","validateRegisterWithArguments","sanitizeCustomProps","sanitizeActiveWhen","sanitizeArguments","isStarted","options","selectors","checkActivityFunctions","unregisterApplication","unloadApplication","waitForUnmount","appIndex","splice","appUnloadInfo","immediatelyUnloadApp","activeApp","triggerAppChange","activityFnArray","activeWhenOrPath","pathToActiveWhen","some","path","exactMatch","regex","lastIndex","inDynamic","regexStr","charIndex","char","appendToRegex","RegExp","commonStringSubPath","slice","suffix","charAt","toDynamicPathValidatorRegex","route","origin","test","appChangeUnderway","promisesWaitingOnAppChange","currentUrl","pendingPromises","silentNavigation","appsToUnmount","appsToLoad","appsToMount","currentTime","appShouldBeActive","getAppChanges","appsThatChanged","cancelPromises","oldUrl","newUrl","fireSingleSpaEvent","getCustomEventDetail","cancelNavigation","cancelValues","v","substring","unloadPromises","allUnmountPromises","unmountAllPromise","loadThenMountPromises","tryToInitAndMount","mountPromises","appToMount","callAllEventListeners","finishUpAndReturn","loadPromises","finally","returnValue","nextPendingPromises","pendingPromise","isBeforeChanges","extraProperties","newAppStatuses","appsByNewStatus","addApp","detail","totalAppChanges","originalEvent","eventProperties","started","start","getRawAppData","toBootstrapPromise","getProfilerData","__SINGLE_SPA_DEVTOOLS__","exposedMethods"],"mappings":"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"}