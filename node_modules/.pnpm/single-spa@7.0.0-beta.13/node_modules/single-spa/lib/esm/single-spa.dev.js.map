{"version":3,"file":"single-spa.dev.js","sources":["../../src/applications/app-errors.ts","../../src/applications/app.helpers.ts","../../src/lifecycles/lifecycle.helpers.ts","../../src/devtools/profiler.ts","../../src/lifecycles/init.ts","../../src/lifecycles/unmount.ts","../../src/lifecycles/mount.ts","../../src/lifecycles/update.ts","../../src/parcels/mount-parcel.ts","../../src/lifecycles/prop.helpers.ts","../../src/applications/timeouts.ts","../../src/lifecycles/load.ts","../../src/utils/runtime-environment.ts","../../src/navigation/navigation-events.ts","../../src/jquery-support.ts","../../src/lifecycles/unload.ts","../../src/applications/apps.ts","../../src/navigation/reroute.ts","../../src/start.ts","../../src/devtools/devtools.ts","../../src/single-spa.ts"],"sourcesContent":["import { AppOrParcel } from \"../lifecycles/lifecycle.helpers\";\nimport { AppOrParcelStatus, objectType, toName } from \"./app.helpers\";\n\nlet errorHandlers: ErrorHandler[] = [];\n\nexport type SingleSpaError = Error & {\n  appOrParcelName: string;\n};\n\nexport type ErrorHandler = (err: SingleSpaError) => any;\n\nexport function handleAppError(\n  err: Error,\n  app: AppOrParcel,\n  newStatus: AppOrParcelStatus,\n) {\n  const transformedErr = transformErr(err, app, newStatus);\n\n  if (errorHandlers.length) {\n    errorHandlers.forEach((handler) => handler(transformedErr));\n  } else {\n    setTimeout(() => {\n      throw transformedErr;\n    });\n  }\n}\n\nexport function addErrorHandler(handler) {\n  if (typeof handler !== \"function\") {\n    throw Error(\n      formatErrorMessage(\n        28,\n        __DEV__ && \"a single-spa error handler must be a function\",\n      ),\n    );\n  }\n\n  errorHandlers.push(handler);\n}\n\nexport function removeErrorHandler(handler) {\n  if (typeof handler !== \"function\") {\n    throw Error(\n      formatErrorMessage(\n        29,\n        __DEV__ && \"a single-spa error handler must be a function\",\n      ),\n    );\n  }\n\n  let removedSomething = false;\n  errorHandlers = errorHandlers.filter((h) => {\n    const isHandler = h === handler;\n    removedSomething = removedSomething || isHandler;\n    return !isHandler;\n  });\n\n  return removedSomething;\n}\n\nexport function formatErrorMessage(code, msg, ...args) {\n  return `single-spa minified message #${code}: ${\n    msg ? msg + \" \" : \"\"\n  }See https://single-spa.js.org/error/?code=${code}${\n    args.length ? `&arg=${args.join(\"&arg=\")}` : \"\"\n  }`;\n}\n\nexport function transformErr(\n  ogErr: Error,\n  appOrParcel: AppOrParcel,\n  newStatus: AppOrParcelStatus,\n): SingleSpaError {\n  const errPrefix = `${objectType(appOrParcel)} '${toName(\n    appOrParcel,\n  )}' died in status ${appOrParcel.status}: `;\n\n  let result: Error;\n\n  if (ogErr instanceof Error) {\n    try {\n      ogErr.message = errPrefix + ogErr.message;\n    } catch (err) {\n      /* Some errors have read-only message properties, in which case there is nothing\n       * that we can do.\n       */\n    }\n    result = ogErr;\n  } else {\n    console.warn(\n      formatErrorMessage(\n        30,\n        __DEV__ &&\n          `While ${appOrParcel.status}, '${toName(\n            appOrParcel,\n          )}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`,\n        appOrParcel.status,\n        toName(appOrParcel),\n      ),\n    );\n    try {\n      result = Error(errPrefix + JSON.stringify(ogErr));\n    } catch (err) {\n      // If it's not an Error and you can't stringify it, then what else can you even do to it?\n      result = ogErr;\n    }\n  }\n\n  const singleSpaErr = result as SingleSpaError;\n  singleSpaErr.appOrParcelName = toName(appOrParcel);\n\n  // We set the status after transforming the error so that the error message\n  // references the state the application was in before the status change.\n  appOrParcel.status = newStatus;\n\n  return singleSpaErr;\n}\n","import {\n  ActivityFn,\n  AppOrParcel,\n  CustomProps,\n  InternalParcel,\n  LoadApp,\n  ParcelMap,\n} from \"../lifecycles/lifecycle.helpers\";\nimport { handleAppError } from \"./app-errors\";\nimport { AppOrParcelTimeouts } from \"./timeouts\";\n\n// App statuses\nexport enum AppOrParcelStatus {\n  NOT_LOADED = \"NOT_LOADED\",\n  LOADING_SOURCE_CODE = \"LOADING_SOURCE_CODE\",\n  NOT_INITIALIZED = \"NOT_INITIALIZED\",\n  INITIALIZING = \"INITIALIZING\",\n  NOT_MOUNTED = \"NOT_MOUNTED\",\n  MOUNTING = \"MOUNTING\",\n  MOUNTED = \"MOUNTED\",\n  UPDATING = \"UPDATING\",\n  UNMOUNTING = \"UNMOUNTING\",\n  UNLOADING = \"UNLOADING\",\n  LOAD_ERROR = \"LOAD_ERROR\",\n  SKIP_BECAUSE_BROKEN = \"SKIP_BECAUSE_BROKEN\",\n}\n\nexport function isActive(app) {\n  return app.status === AppOrParcelStatus.MOUNTED;\n}\n\nexport function shouldBeActive(app) {\n  try {\n    return app.activeWhen(window.location);\n  } catch (err) {\n    handleAppError(err, app, AppOrParcelStatus.SKIP_BECAUSE_BROKEN);\n    return false;\n  }\n}\n\nexport function toName(app) {\n  return app.name;\n}\n\nexport function isParcel(\n  appOrParcel: AppOrParcel,\n): appOrParcel is InternalParcel {\n  return Boolean((appOrParcel as InternalParcel).unmountThisParcel);\n}\n\nexport function objectType(appOrParcel: AppOrParcel): \"parcel\" | \"application\" {\n  return isParcel(appOrParcel) ? \"parcel\" : \"application\";\n}\n\nexport interface InternalApplication {\n  name: string;\n  activeWhen: ActivityFn;\n  loadApp: LoadApp;\n  status: AppOrParcelStatus;\n  loadErrorTime: number;\n  parcels: ParcelMap;\n  customProps?: CustomProps;\n  // The ensureValidAppTimeouts function gets called once the app is loaded\n  timeouts?: AppOrParcelTimeouts;\n  devtools: AppDevtools;\n}\n\nexport interface AppDevtools {\n  overlays: {\n    options: OverlayOptions;\n    selectors: string[];\n  };\n}\n\n// https://github.com/single-spa/single-spa-inspector/blob/ac3e1ded68e94239dd02d04f8a094ed8e6dfefc2/src/inspected-window-helpers/overlay-helpers.js#L53\ninterface OverlayOptions {\n  color?: string;\n  background?: string;\n  classes?: string[];\n  height?: string;\n  left?: string;\n  position?: string;\n  top?: string;\n  width?: string;\n  zIndex?: string | number;\n  textColor?: string;\n  textBlocks?: string[];\n}\n","import {\n  toName,\n  AppOrParcelStatus,\n  InternalApplication,\n  AppDevtools,\n} from \"../applications/app.helpers\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { AppOrParcelTimeouts } from \"../applications/timeouts\";\n\nexport function validLifecycleFn(\n  fn: LifeCycleFn<unknown> | LifeCycleFn<unknown>[],\n): boolean {\n  return fn && (typeof fn === \"function\" || isArrayOfFns(fn));\n\n  function isArrayOfFns(arr) {\n    return (\n      Array.isArray(arr) && !arr.find((item) => typeof item !== \"function\")\n    );\n  }\n}\n\nexport function flattenFnArray(\n  appOrParcel: LifeCycles<unknown>,\n  lifecycle: string,\n  isParcel: boolean,\n): LifeCycleFn<unknown> {\n  let fns: LifeCycleFn<unknown>[] = Array.isArray(appOrParcel[lifecycle])\n    ? (appOrParcel[lifecycle] as LifeCycleFn<unknown>[])\n    : [appOrParcel[lifecycle] as LifeCycleFn<unknown>].filter(Boolean);\n  if (fns.length === 0) {\n    fns = [() => Promise.resolve()];\n  }\n\n  const type = isParcel ? \"parcel\" : \"application\";\n  const name = toName(appOrParcel);\n\n  return function (props: AppProps): Promise<unknown> {\n    return fns.reduce((resultPromise, fn, index) => {\n      return resultPromise.then(() => {\n        const thisPromise = fn(props);\n        return smellsLikeAPromise(thisPromise)\n          ? thisPromise\n          : Promise.reject(\n              formatErrorMessage(\n                15,\n                __DEV__ &&\n                  `Within ${type} ${name}, the lifecycle function ${lifecycle} at array index ${index} did not return a promise`,\n                type,\n                name,\n                lifecycle,\n                index,\n              ),\n            );\n      });\n    }, Promise.resolve());\n  };\n}\n\nexport function smellsLikeAPromise(promise) {\n  return (\n    promise &&\n    typeof promise.then === \"function\" &&\n    typeof promise.catch === \"function\"\n  );\n}\n\nexport interface CustomProps {\n  [str: string]: any;\n  [num: number]: any;\n}\n\nexport interface ParcelCustomProps extends CustomProps {\n  domElement: HTMLElement;\n}\n\nexport type CustomPropsFn<ExtraProps extends CustomProps = CustomProps> = (\n  name: string,\n  location: Location,\n) => ExtraProps;\n\nexport type AppProps = {\n  name: string;\n  mountParcel(\n    parcelConfig: ParcelConfig,\n    customProps: ParcelProps & CustomProps,\n  ): Parcel;\n};\n\nexport type ParcelConfig<ExtraProps = CustomProps> =\n  | ParcelConfigObject<ExtraProps>\n  | (() => Promise<ParcelConfigObject<ExtraProps>>);\n\ntype ParcelProps = { domElement: HTMLElement };\nexport type ParcelConfigObject<ExtraProps = CustomProps> = {\n  name?: string;\n  timeouts?: AppOrParcelTimeouts;\n} & LifeCycles<ExtraProps>;\n\nexport type LifeCycleFn<ExtraProps> = (\n  config: ExtraProps & AppProps,\n) => Promise<any>;\nexport type LifeCycles<ExtraProps = {}> = {\n  init?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  mount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  unmount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  update?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  unload?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  devtools?: AppDevtools;\n  timeouts?: AppOrParcelTimeouts;\n};\n\nexport type Parcel<ExtraProps = CustomProps> = {\n  mount(): Promise<null>;\n  unmount(): Promise<null>;\n  update?(customProps: ExtraProps): Promise<any>;\n  getStatus(): AppOrParcelStatus;\n  loadPromise: Promise<null>;\n  initPromise: Promise<null>;\n  mountPromise: Promise<null>;\n  unmountPromise: Promise<null>;\n  // Intended for internal use only\n  _parcel: InternalParcel;\n};\n\nexport interface ParcelOwner {\n  name: string;\n  parcels: ParcelMap;\n}\n\nexport interface ParcelMap {\n  [parcelId: number]: InternalParcel;\n}\n\n// Intended for internal use only\nexport interface InternalParcel {\n  id: number;\n  name: string;\n  init: LifeCycles[\"init\"];\n  mount: LifeCycles[\"mount\"];\n  unmount: LifeCycles[\"unmount\"];\n  update: LifeCycles[\"update\"];\n  parcels: ParcelMap;\n  status: AppOrParcelStatus;\n  customProps: CustomProps;\n  parentName: string;\n  unmountThisParcel(): Promise<AppOrParcel>;\n  currentTask: Promise<LoadedAppOrParcel>;\n  timeouts: AppOrParcelTimeouts;\n}\n\nexport type AppOrParcel = InternalApplication | InternalParcel;\n\ninterface Loaded extends LifeCycles {\n  // loadPromise sometimes bails early if there is an error,\n  // which results in it being an InternalApplication\n  loadPromise?: Promise<LoadedApp | InternalApplication>;\n}\n\nexport type LoadedAppOrParcel =\n  | (InternalApplication & Loaded)\n  | (InternalParcel & Loaded);\n\nexport type LoadedApp = InternalApplication & Loaded;\n\nexport type Application<ExtraProps = {}> =\n  | LifeCycles<ExtraProps>\n  | LoadApp<ExtraProps>;\n\nexport type LoadApp<ExtraProps = {}> = (\n  config: ExtraProps & AppProps,\n) => Promise<LifeCycles<ExtraProps>>;\n\nexport interface SingleSpaLocation {\n  pathname: URL[\"pathname\"];\n  hash?: URL[\"hash\"];\n  search?: string;\n}\n\nexport type ActivityFn = (location: SingleSpaLocation) => boolean;\n\nexport type Activity = ActivityFn | string | (ActivityFn | string)[];\n\nexport type RegisterApplicationConfig<ExtraProps extends CustomProps = {}> = {\n  name: string;\n  app: Application<ExtraProps>;\n  activeWhen: Activity;\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>;\n};\n","let profileEntries: ProfileEntry[] = [];\n\nexport interface ProfileEntry {\n  type: \"application\" | \"parcel\" | \"routing\";\n  name: string;\n  kind:\n    | \"init\"\n    | \"load\"\n    | \"mount\"\n    | \"unload\"\n    | \"unmount\"\n    | \"update\"\n    | \"loadApps\"\n    | \"silentNavigation\"\n    | \"browserNavigation\"\n    | \"triggerAppChange\";\n  operationSucceeded: boolean;\n  start: number;\n  end: number;\n}\n\nexport function getProfilerData() {\n  return profileEntries;\n}\n\nexport function addProfileEntry(\n  type: ProfileEntry[\"type\"],\n  name: ProfileEntry[\"name\"],\n  kind: ProfileEntry[\"kind\"],\n  start: ProfileEntry[\"start\"],\n  end: ProfileEntry[\"end\"],\n  operationSucceeded: ProfileEntry[\"operationSucceeded\"],\n): void {\n  profileEntries.push({\n    type,\n    name,\n    start,\n    end,\n    kind,\n    operationSucceeded,\n  });\n}\n\nexport function clearProfilerData(): void {\n  profileEntries = [];\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  isParcel,\n} from \"../applications/app.helpers\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { handleAppError, transformErr } from \"../applications/app-errors\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nexport function toInitPromise(\n  appOrParcel: LoadedAppOrParcel,\n  hardFail?: boolean,\n): Promise<LoadedAppOrParcel> {\n  let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== AppOrParcelStatus.NOT_INITIALIZED) {\n      return appOrParcel;\n    }\n\n    if (__PROFILE__) {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    appOrParcel.status = AppOrParcelStatus.INITIALIZING;\n\n    return reasonableTime(appOrParcel, \"init\")\n      .then(successfulInit)\n      .catch((err) => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"init\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        if (hardFail) {\n          throw transformErr(\n            err,\n            appOrParcel,\n            AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n          );\n        } else {\n          handleAppError(\n            err,\n            appOrParcel,\n            AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n          );\n          return appOrParcel;\n        }\n      });\n  });\n\n  function successfulInit(): LoadedAppOrParcel {\n    appOrParcel.status = AppOrParcelStatus.NOT_MOUNTED;\n\n    if (__PROFILE__) {\n      addProfileEntry(\n        profileEventType,\n        toName(appOrParcel),\n        \"init\",\n        startTime,\n        performance.now(),\n        true,\n      );\n    }\n\n    return appOrParcel;\n  }\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  isParcel,\n} from \"../applications/app.helpers\";\nimport { handleAppError, transformErr } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nexport function toUnmountPromise(\n  appOrParcel: LoadedAppOrParcel,\n  hardFail?: boolean,\n): Promise<LoadedAppOrParcel> {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== AppOrParcelStatus.MOUNTED) {\n      return appOrParcel;\n    }\n\n    let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n    if (__PROFILE__) {\n      startTime = performance.now();\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n    }\n\n    appOrParcel.status = AppOrParcelStatus.UNMOUNTING;\n\n    const unmountChildrenParcels = Object.keys(appOrParcel.parcels).map(\n      (parcelId) => appOrParcel.parcels[parcelId].unmountThisParcel(),\n    );\n\n    let parcelError: Error;\n\n    return Promise.all(unmountChildrenParcels)\n      .then(unmountAppOrParcel, (parcelError) => {\n        // There is a parcel unmount error\n        return unmountAppOrParcel().then(() => {\n          // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n          const parentError = Error(parcelError.message);\n          if (hardFail) {\n            throw transformErr(\n              parentError,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          } else {\n            handleAppError(\n              parentError,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          }\n        });\n      })\n      .then(() => appOrParcel);\n\n    function unmountAppOrParcel() {\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      return reasonableTime(appOrParcel, \"unmount\").then(\n        () => {\n          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelError) {\n            appOrParcel.status = AppOrParcelStatus.NOT_MOUNTED;\n          }\n\n          if (__PROFILE__) {\n            addProfileEntry(\n              profileEventType,\n              toName(appOrParcel),\n              \"unmount\",\n              startTime,\n              performance.now(),\n              true,\n            );\n          }\n        },\n        (err) => {\n          if (__PROFILE__) {\n            addProfileEntry(\n              profileEventType,\n              toName(appOrParcel),\n              \"unmount\",\n              startTime,\n              performance.now(),\n              false,\n            );\n          }\n\n          if (hardFail) {\n            throw transformErr(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          } else {\n            handleAppError(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          }\n        },\n      );\n    }\n  });\n}\n","import {\n  toName,\n  isParcel,\n  AppOrParcelStatus,\n} from \"../applications/app.helpers\";\nimport { handleAppError, transformErr } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { toUnmountPromise } from \"./unmount\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nlet beforeFirstMountFired: boolean = false;\nlet firstMountFired: boolean = false;\n\nexport function toMountPromise(\n  appOrParcel: LoadedAppOrParcel,\n  hardFail?: boolean,\n): Promise<LoadedAppOrParcel> {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== AppOrParcelStatus.NOT_MOUNTED) {\n      return appOrParcel;\n    }\n\n    let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n    if (__PROFILE__) {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new CustomEvent(\"single-spa:before-first-mount\"));\n      beforeFirstMountFired = true;\n    }\n\n    appOrParcel.status = AppOrParcelStatus.MOUNTING;\n\n    return reasonableTime(appOrParcel, \"mount\")\n      .then(() => {\n        appOrParcel.status = AppOrParcelStatus.MOUNTED;\n\n        if (!firstMountFired) {\n          window.dispatchEvent(new CustomEvent(\"single-spa:first-mount\"));\n          firstMountFired = true;\n        }\n\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"mount\",\n            startTime,\n            performance.now(),\n            true,\n          );\n        }\n\n        return appOrParcel;\n      })\n      .catch((err) => {\n        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        appOrParcel.status = AppOrParcelStatus.MOUNTED;\n        return toUnmountPromise(appOrParcel, true).then(\n          setSkipBecauseBroken,\n          setSkipBecauseBroken,\n        );\n\n        function setSkipBecauseBroken() {\n          if (__PROFILE__) {\n            addProfileEntry(\n              profileEventType,\n              toName(appOrParcel),\n              \"mount\",\n              startTime,\n              performance.now(),\n              false,\n            );\n          }\n\n          if (!hardFail) {\n            handleAppError(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n            return appOrParcel;\n          } else {\n            throw transformErr(\n              err,\n              appOrParcel,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n          }\n        }\n      });\n  });\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  isParcel,\n} from \"../applications/app.helpers\";\nimport { transformErr, formatErrorMessage } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedAppOrParcel } from \"./lifecycle.helpers\";\n\nexport function toUpdatePromise(\n  appOrParcel: LoadedAppOrParcel,\n): Promise<LoadedAppOrParcel> {\n  return Promise.resolve().then(() => {\n    let startTime: number, profileEventType: ProfileEntry[\"type\"];\n\n    if (__PROFILE__) {\n      profileEventType = isParcel(appOrParcel) ? \"parcel\" : \"application\";\n      startTime = performance.now();\n    }\n\n    if (appOrParcel.status !== AppOrParcelStatus.MOUNTED) {\n      throw Error(\n        formatErrorMessage(\n          32,\n          __DEV__ &&\n            `Cannot update parcel '${toName(\n              appOrParcel,\n            )}' because it is not mounted`,\n          toName(appOrParcel),\n        ),\n      );\n    }\n\n    appOrParcel.status = AppOrParcelStatus.UPDATING;\n\n    return reasonableTime(appOrParcel, \"update\")\n      .then(() => {\n        appOrParcel.status = AppOrParcelStatus.MOUNTED;\n\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"update\",\n            startTime,\n            performance.now(),\n            true,\n          );\n        }\n\n        return appOrParcel;\n      })\n      .catch((err) => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            profileEventType,\n            toName(appOrParcel),\n            \"update\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        throw transformErr(\n          err,\n          appOrParcel,\n          AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n        );\n      });\n  });\n}\n","import {\n  validLifecycleFn,\n  flattenFnArray,\n  CustomProps,\n  Parcel,\n  ParcelCustomProps,\n  ParcelConfigObject,\n  ParcelConfig,\n  ParcelOwner,\n  InternalParcel,\n} from \"../lifecycles/lifecycle.helpers\";\nimport { AppOrParcelStatus, toName } from \"../applications/app.helpers\";\nimport { toInitPromise } from \"../lifecycles/init\";\nimport { toMountPromise } from \"../lifecycles/mount\";\nimport { toUpdatePromise } from \"../lifecycles/update\";\nimport { toUnmountPromise } from \"../lifecycles/unmount\";\nimport { ensureValidAppTimeouts } from \"../applications/timeouts\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\n\nlet parcelCount: number = 0;\nconst rootParcels: ParcelOwner = { name: \"rootParcels\", parcels: {} };\n\n// This is a public api, exported to users of single-spa\nexport function mountRootParcel(\n  config: ParcelConfig,\n  customProps: CustomProps,\n) {\n  return mountParcel.call(rootParcels, config, customProps);\n}\n\nexport function mountParcel(\n  this: ParcelOwner,\n  config: ParcelConfig,\n  customProps: ParcelCustomProps,\n) {\n  const owningAppOrParcel = this;\n\n  // Validate inputs\n  if (!config || (typeof config !== \"object\" && typeof config !== \"function\")) {\n    throw Error(\n      formatErrorMessage(\n        2,\n        __DEV__ &&\n          \"Cannot mount parcel without a config object or config loading function\",\n      ),\n    );\n  }\n\n  if (config.name && typeof config.name !== \"string\") {\n    throw Error(\n      formatErrorMessage(\n        3,\n        __DEV__ &&\n          `Parcel name must be a string, if provided. Was given ${typeof config.name}`,\n        typeof config.name,\n      ),\n    );\n  }\n\n  const id = parcelCount++;\n  let name = config.name || `parcel-${id}`;\n\n  if (typeof customProps !== \"object\") {\n    throw Error(\n      formatErrorMessage(\n        4,\n        __DEV__ &&\n          `Parcel ${name} has invalid customProps -- must be an object but was given ${typeof customProps}`,\n        name,\n        typeof customProps,\n      ),\n    );\n  }\n\n  if (!customProps.domElement) {\n    throw Error(\n      formatErrorMessage(\n        5,\n        __DEV__ &&\n          `Parcel ${name} cannot be mounted without a domElement provided as a prop`,\n        name,\n      ),\n    );\n  }\n\n  const passedConfigLoadingFunction = typeof config === \"function\";\n  const configLoadingFunction: () => Promise<ParcelConfigObject<CustomProps>> =\n    passedConfigLoadingFunction ? config : () => Promise.resolve(config);\n\n  // Internal representation\n  const parcel: Partial<InternalParcel> = {\n    id,\n    parcels: {},\n    status: passedConfigLoadingFunction\n      ? AppOrParcelStatus.LOADING_SOURCE_CODE\n      : AppOrParcelStatus.NOT_INITIALIZED,\n    customProps,\n    parentName: toName(owningAppOrParcel),\n    currentTask: undefined,\n    unmountThisParcel() {\n      return parcel.currentTask.then(() => {\n        if (parcel.status !== AppOrParcelStatus.MOUNTED) {\n          throw Error(\n            formatErrorMessage(\n              6,\n              __DEV__ &&\n                `Cannot unmount parcel '${name}' -- it is in a ${parcel.status} status`,\n              name,\n              parcel.status,\n            ),\n          );\n        }\n\n        return toUnmountPromise(parcel as InternalParcel, true)\n          .then((value) => {\n            if (parcel.parentName) {\n              delete owningAppOrParcel.parcels[parcel.id];\n            }\n\n            return value;\n          })\n          .then((value) => {\n            resolveUnmount(value);\n            return value;\n          })\n          .catch((err) => {\n            parcel.status = AppOrParcelStatus.SKIP_BECAUSE_BROKEN;\n            rejectUnmount(err);\n            throw err;\n          });\n      });\n    },\n  };\n\n  let loadPromise = configLoadingFunction();\n\n  if (!loadPromise || typeof loadPromise.then !== \"function\") {\n    throw Error(\n      formatErrorMessage(\n        7,\n        __DEV__ &&\n          `When mounting a parcel, the config loading function must return a promise that resolves with the parcel config`,\n      ),\n    );\n  }\n\n  loadPromise = loadPromise.then((config) => {\n    if (!config) {\n      throw Error(\n        formatErrorMessage(\n          8,\n          __DEV__ &&\n            `When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config`,\n        ),\n      );\n    }\n\n    name = config.name || `parcel-${id}`;\n\n    if (\n      // ES Module objects don't have the object prototype\n      Object.prototype.hasOwnProperty.call(config, \"init\") &&\n      !validLifecycleFn(config.init)\n    ) {\n      throw Error(\n        formatErrorMessage(\n          9,\n          __DEV__ && `Parcel ${name} provided an invalid init function`,\n          name,\n        ),\n      );\n    }\n\n    if (!validLifecycleFn(config.mount)) {\n      throw Error(\n        formatErrorMessage(\n          10,\n          __DEV__ && `Parcel ${name} must have a valid mount function`,\n          name,\n        ),\n      );\n    }\n\n    if (!validLifecycleFn(config.unmount)) {\n      throw Error(\n        formatErrorMessage(\n          11,\n          __DEV__ && `Parcel ${name} must have a valid unmount function`,\n          name,\n        ),\n      );\n    }\n\n    if (config.update && !validLifecycleFn(config.update)) {\n      throw Error(\n        formatErrorMessage(\n          12,\n          __DEV__ && `Parcel ${name} provided an invalid update function`,\n          name,\n        ),\n      );\n    }\n\n    const init = flattenFnArray(\n      config,\n      config.init ? \"init\" : \"bootstrap\",\n      true,\n    );\n    const mount = flattenFnArray(config, \"mount\", true);\n    const unmount = flattenFnArray(config, \"unmount\", true);\n\n    parcel.status = AppOrParcelStatus.NOT_INITIALIZED;\n    parcel.name = name;\n    parcel.init = init;\n    parcel.mount = mount;\n    parcel.unmount = unmount;\n    parcel.timeouts = ensureValidAppTimeouts(config.timeouts);\n\n    if (config.update) {\n      parcel.update = flattenFnArray(config, \"update\", true);\n    }\n\n    const fullParcel: InternalParcel = parcel as InternalParcel;\n\n    // Add to owning app or parcel\n    owningAppOrParcel.parcels[id] = fullParcel;\n\n    return config;\n  });\n\n  // Start initializing and mounting\n  // The .then() causes the work to be put on the event loop instead of happening immediately\n  const initPromise = loadPromise.then(() =>\n    toInitPromise(parcel as InternalParcel, true),\n  );\n\n  const mountPromise = initPromise.then(\n    () => (parcel.currentTask = toMountPromise(parcel as InternalParcel, true)),\n  );\n  parcel.currentTask = mountPromise;\n\n  let resolveUnmount, rejectUnmount;\n\n  const unmountPromise = new Promise((resolve, reject) => {\n    resolveUnmount = resolve;\n    rejectUnmount = reject;\n  });\n\n  let externalRepresentation: Parcel = {\n    mount() {\n      return promiseWithoutReturnValue(\n        Promise.resolve().then(() => {\n          if (parcel.status !== AppOrParcelStatus.NOT_MOUNTED) {\n            throw Error(\n              formatErrorMessage(\n                13,\n                __DEV__ &&\n                  `Cannot mount parcel '${name}' -- it is in a ${parcel.status} status`,\n                name,\n                parcel.status,\n              ),\n            );\n          }\n\n          // Add to owning app or parcel\n          owningAppOrParcel.parcels[id] = parcel as InternalParcel;\n\n          return toMountPromise(parcel as InternalParcel);\n        }),\n      );\n    },\n    unmount() {\n      return promiseWithoutReturnValue(parcel.unmountThisParcel());\n    },\n    getStatus() {\n      return parcel.status;\n    },\n    loadPromise: promiseWithoutReturnValue(loadPromise),\n    initPromise: promiseWithoutReturnValue(initPromise),\n    mountPromise: promiseWithoutReturnValue(mountPromise),\n    unmountPromise: promiseWithoutReturnValue(unmountPromise),\n    _parcel: parcel as InternalParcel,\n  };\n\n  loadPromise.then(\n    (config) => {\n      if (config.update) {\n        externalRepresentation.update = function (customProps) {\n          return (parcel.currentTask = parcel.currentTask.then(() => {\n            parcel.customProps = customProps;\n\n            return promiseWithoutReturnValue(\n              toUpdatePromise(parcel as InternalParcel),\n            );\n          }));\n        };\n      }\n    },\n    () => {\n      // This catch handler avoids unhandled rejections.\n      // User code can handle the rejection via externalRepresentation.loadPromise.catch\n    },\n  );\n\n  return externalRepresentation;\n}\n\nfunction promiseWithoutReturnValue(promise) {\n  return promise.then(() => null);\n}\n","import { mountParcel } from \"../parcels/mount-parcel\";\nimport { isParcel, toName } from \"../applications/app.helpers\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { AppOrParcel, CustomProps, InternalParcel } from \"./lifecycle.helpers\";\n\ninterface SingleSpaProps {\n  name: string;\n  mountParcel: typeof mountParcel;\n  unmountSelf(): Promise<AppOrParcel>;\n}\n\nexport function getProps(\n  appOrParcel: AppOrParcel,\n): SingleSpaProps & CustomProps {\n  const name = toName(appOrParcel);\n  let customProps =\n    typeof appOrParcel.customProps === \"function\"\n      ? appOrParcel.customProps(name, window.location)\n      : appOrParcel.customProps;\n  if (\n    typeof customProps !== \"object\" ||\n    customProps === null ||\n    Array.isArray(customProps)\n  ) {\n    customProps = {};\n    console.warn(\n      formatErrorMessage(\n        40,\n        __DEV__ &&\n          `single-spa: ${name}'s customProps function must return an object. Received ${customProps}`,\n      ),\n      name,\n      customProps,\n    );\n  }\n  const result: SingleSpaProps = Object.assign({}, customProps, {\n    name,\n    mountParcel: mountParcel.bind(appOrParcel),\n  });\n\n  if (isParcel(appOrParcel)) {\n    result.unmountSelf = appOrParcel.unmountThisParcel;\n  }\n\n  return result;\n}\n","import { getProps } from \"../lifecycles/prop.helpers\";\nimport { objectType, toName } from \"./app.helpers\";\nimport { formatErrorMessage } from \"./app-errors\";\nimport { AppOrParcel } from \"../lifecycles/lifecycle.helpers\";\n\nexport interface AppOrParcelTimeouts {\n  init: Timeout;\n  mount: Timeout;\n  unmount: Timeout;\n  unload: Timeout;\n  update: Timeout;\n}\n\nexport interface Timeout {\n  millis: number;\n  dieOnTimeout: boolean;\n  warningMillis: number;\n}\n\nconst defaultWarningMillis: number = 1000;\n\nconst globalTimeoutConfig: AppOrParcelTimeouts = {\n  init: {\n    millis: 4000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  mount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unmount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unload: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  update: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n};\n\nexport function setInitMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n): void {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        16,\n        __DEV__ &&\n          `init max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.init = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function setMountMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n): void {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        17,\n        __DEV__ &&\n          `mount max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.mount = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function setUnmountMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        18,\n        __DEV__ &&\n          `unmount max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.unmount = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function setUnloadMaxTime(\n  time: number,\n  dieOnTimeout: boolean,\n  warningMillis: number,\n) {\n  if (typeof time !== \"number\" || time <= 0) {\n    throw Error(\n      formatErrorMessage(\n        19,\n        __DEV__ &&\n          `unload max time must be a positive integer number of milliseconds`,\n      ),\n    );\n  }\n\n  globalTimeoutConfig.unload = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\nexport function reasonableTime(\n  appOrParcel: AppOrParcel,\n  lifecycle: \"init\" | \"mount\" | \"update\" | \"unmount\" | \"unload\",\n): Promise<any> {\n  const timeoutConfig = appOrParcel.timeouts[lifecycle];\n  const warningPeriod = timeoutConfig.warningMillis;\n  const type = objectType(appOrParcel);\n\n  return new Promise((resolve, reject) => {\n    let finished: boolean = false;\n    let errored: boolean = false;\n\n    appOrParcel[lifecycle](getProps(appOrParcel))\n      .then((val) => {\n        finished = true;\n        resolve(val);\n      })\n      .catch((val) => {\n        finished = true;\n        reject(val);\n      });\n\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n    const errMsg = formatErrorMessage(\n      31,\n      __DEV__ &&\n        `Lifecycle function ${lifecycle} for ${type} ${toName(\n          appOrParcel,\n        )} lifecycle did not resolve or reject for ${timeoutConfig.millis} ms.`,\n      lifecycle,\n      type,\n      toName(appOrParcel),\n      timeoutConfig.millis,\n    );\n\n    function maybeTimingOut(shouldError: true | number) {\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n          if (timeoutConfig.dieOnTimeout) {\n            reject(Error(errMsg));\n          } else {\n            console.error(errMsg);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          const numWarnings: number = shouldError;\n          const numMillis = numWarnings * warningPeriod;\n          console.warn(errMsg);\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\n\nexport function ensureValidAppTimeouts(\n  timeouts: Partial<AppOrParcelTimeouts>,\n): AppOrParcelTimeouts {\n  const result = {};\n\n  for (let key in globalTimeoutConfig) {\n    result[key] = Object.assign(\n      {},\n      globalTimeoutConfig[key],\n      timeouts?.[key] ?? {},\n    );\n  }\n\n  return result as AppOrParcelTimeouts;\n}\n","import {\n  AppOrParcelStatus,\n  toName,\n  InternalApplication,\n} from \"../applications/app.helpers\";\nimport { ensureValidAppTimeouts } from \"../applications/timeouts\";\nimport { handleAppError, formatErrorMessage } from \"../applications/app-errors\";\nimport {\n  LifeCycles,\n  LoadedApp,\n  flattenFnArray,\n  smellsLikeAPromise,\n  validLifecycleFn,\n} from \"./lifecycle.helpers\";\nimport { getProps } from \"./prop.helpers\";\nimport { addProfileEntry } from \"../devtools/profiler\";\n\nexport function toLoadPromise(\n  app: InternalApplication | LoadedApp,\n): Promise<LoadedApp | InternalApplication> {\n  return Promise.resolve().then(() => {\n    if ((app as LoadedApp).loadPromise) {\n      return (app as LoadedApp).loadPromise;\n    }\n\n    if (\n      app.status !== AppOrParcelStatus.NOT_LOADED &&\n      app.status !== AppOrParcelStatus.LOAD_ERROR\n    ) {\n      return app;\n    }\n\n    let startTime: number;\n    if (__PROFILE__) {\n      startTime = performance.now();\n    }\n\n    const appBeingLoaded: InternalApplication & Partial<LoadedApp> = app;\n\n    appBeingLoaded.status = AppOrParcelStatus.LOADING_SOURCE_CODE;\n\n    let lifecycles: LifeCycles, isUserErr: boolean;\n\n    return (appBeingLoaded.loadPromise = Promise.resolve()\n      .then(() => {\n        const loadPromise = appBeingLoaded.loadApp(getProps(app));\n        if (!smellsLikeAPromise(loadPromise)) {\n          // The name of the app will be prepended to this error message inside of the handleAppError function\n          isUserErr = true;\n          throw Error(\n            formatErrorMessage(\n              33,\n              __DEV__ &&\n                `single-spa loading function did not return a promise. Check the second argument to registerApplication('${toName(\n                  app,\n                )}', loadingFunction, activityFunction)`,\n              toName(appBeingLoaded),\n            ),\n          );\n        }\n        return loadPromise.then((val) => {\n          appBeingLoaded.loadErrorTime = null;\n\n          lifecycles = val;\n\n          let validationErrMessage, validationErrCode;\n\n          if (typeof lifecycles !== \"object\") {\n            validationErrCode = 34;\n            if (__DEV__) {\n              validationErrMessage = `does not export anything`;\n            }\n          }\n\n          if (!validLifecycleFn(lifecycles.mount)) {\n            validationErrCode = 36;\n            if (__DEV__) {\n              validationErrMessage = `does not export a mount function or array of functions`;\n            }\n          }\n\n          if (!validLifecycleFn(lifecycles.unmount)) {\n            validationErrCode = 37;\n            if (__DEV__) {\n              validationErrMessage = `does not export a unmount function or array of functions`;\n            }\n          }\n\n          if (validationErrCode) {\n            let appOptsStr;\n            try {\n              appOptsStr = JSON.stringify(lifecycles);\n            } catch {}\n            console.error(\n              formatErrorMessage(\n                validationErrCode,\n                __DEV__ &&\n                  `The loading function for single-spa application '${toName(\n                    appBeingLoaded,\n                  )}' resolved with the following, which does not have mount and unmount functions`,\n                \"application\",\n                toName(appBeingLoaded),\n                appOptsStr,\n              ),\n              lifecycles,\n            );\n            handleAppError(\n              validationErrMessage,\n              appBeingLoaded,\n              AppOrParcelStatus.SKIP_BECAUSE_BROKEN,\n            );\n            return appBeingLoaded;\n          }\n\n          if (lifecycles.devtools && lifecycles.devtools.overlays) {\n            appBeingLoaded.devtools.overlays = Object.assign(\n              {},\n              app.devtools.overlays,\n              lifecycles.devtools.overlays,\n            );\n          }\n\n          appBeingLoaded.status = AppOrParcelStatus.NOT_INITIALIZED;\n          appBeingLoaded.init = flattenFnArray(lifecycles, \"init\", false);\n          appBeingLoaded.mount = flattenFnArray(lifecycles, \"mount\", false);\n          appBeingLoaded.unmount = flattenFnArray(lifecycles, \"unmount\", false);\n          appBeingLoaded.unload = flattenFnArray(lifecycles, \"unload\", false);\n          appBeingLoaded.timeouts = ensureValidAppTimeouts(lifecycles.timeouts);\n\n          delete appBeingLoaded.loadPromise;\n\n          if (__PROFILE__) {\n            addProfileEntry(\n              \"application\",\n              toName(appBeingLoaded),\n              \"load\",\n              startTime,\n              performance.now(),\n              true,\n            );\n          }\n\n          return appBeingLoaded as LoadedApp;\n        });\n      })\n      .catch((err) => {\n        delete appBeingLoaded.loadPromise;\n\n        let newStatus;\n        if (isUserErr) {\n          newStatus = AppOrParcelStatus.SKIP_BECAUSE_BROKEN;\n        } else {\n          newStatus = AppOrParcelStatus.LOAD_ERROR;\n          appBeingLoaded.loadErrorTime = new Date().getTime();\n        }\n        handleAppError(err, appBeingLoaded, newStatus);\n\n        if (__PROFILE__) {\n          addProfileEntry(\n            \"application\",\n            toName(appBeingLoaded),\n            \"load\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        return appBeingLoaded as LoadedApp;\n      }));\n  });\n}\n","export const isInBrowser = typeof window !== \"undefined\";\n","import { reroute } from \"./reroute\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { isInBrowser } from \"../utils/runtime-environment\";\nimport { StartOpts } from \"../start\";\n\n/* We capture navigation event listeners so that we can make sure\n * that application navigation listeners are not called until\n * single-spa has ensured that the correct applications are\n * unmounted and mounted.\n */\nconst capturedEventListeners: CapturedEventListeners = {\n  hashchange: [],\n  popstate: [],\n};\n\ninterface CapturedEventListeners {\n  hashchange: ((this: Window, ev: HashChangeEvent) => any)[];\n  popstate: ((this: Window, ev: PopStateEvent) => any)[];\n}\n\nexport const routingEventsListeningTo = [\"hashchange\", \"popstate\"];\n\ntype NavigateArg = string | HTMLAnchorElement | MouseEvent;\n\nexport function navigateToUrl(obj: NavigateArg): void {\n  let url;\n  if (typeof obj === \"string\") {\n    url = obj;\n  } else if (this && this.href) {\n    url = this.href;\n  } else if (\n    obj &&\n    \"currentTarget\" in obj &&\n    \"href\" in obj.currentTarget &&\n    \"preventDefault\" in obj\n  ) {\n    url = ((obj as MouseEvent).currentTarget as HTMLAnchorElement).href;\n    (obj as MouseEvent).preventDefault();\n  } else {\n    throw Error(\n      formatErrorMessage(\n        14,\n        __DEV__ &&\n          `singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`,\n      ),\n    );\n  }\n\n  const current = new URL(window.location.href);\n  const destination = new URL(url, window.location.href);\n\n  if (url.indexOf(\"#\") === 0) {\n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    if (process.env.BABEL_ENV === \"test\") {\n      // @ts-expect-error test-only return value\n      return { wouldHaveReloadedThePage: true };\n    } else {\n      window.location.href = url;\n    }\n  } else if (\n    destination.pathname === current.pathname &&\n    destination.search === current.search\n  ) {\n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushState(null, null, url);\n  }\n}\n\nexport function callCapturedEventListeners(\n  eventArguments: [HashChangeEvent | PopStateEvent],\n): void {\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      capturedEventListeners[eventType].forEach((listener) => {\n        try {\n          // The error thrown by application event listener should not break single-spa down.\n          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did\n          listener.apply(this, eventArguments);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\n\nlet urlRerouteOnly: boolean;\n\nfunction urlReroute(evt: HashChangeEvent | PopStateEvent) {\n  reroute([], [evt]);\n}\n\ntype UpdateState = (data: any, unused: string, url?: string | URL) => void;\n\nfunction patchedUpdateState(\n  updateState: UpdateState,\n  methodName: \"pushState\" | \"replaceState\",\n) {\n  return function () {\n    const urlBefore = window.location.href;\n    const result = updateState.apply(this, arguments);\n    const urlAfter = window.location.href;\n\n    if (!urlRerouteOnly || urlBefore !== urlAfter) {\n      // fire an artificial popstate event so that\n      // single-spa applications know about routing that\n      // occurs in a different application\n      window.dispatchEvent(\n        createPopStateEvent(window.history.state, methodName),\n      );\n    }\n\n    return result;\n  };\n}\n\ninterface SingleSpaPopStateEvent extends PopStateEvent {\n  singleSpa: boolean;\n  singleSpaTrigger: string;\n}\n\nfunction createPopStateEvent(\n  state,\n  originalMethodName,\n): SingleSpaPopStateEvent {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn't fire one by default when you call replaceState, so that\n  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and\n  // singleSpaTrigger=<pushState|replaceState> on the event instance.\n  let evt = new PopStateEvent(\"popstate\", { state });\n  (evt as SingleSpaPopStateEvent).singleSpa = true;\n  (evt as SingleSpaPopStateEvent).singleSpaTrigger = originalMethodName;\n  return evt as SingleSpaPopStateEvent;\n}\n\nexport let originalReplaceState: (\n  data: any,\n  unused: string,\n  url?: string | URL,\n) => void = null;\n\nlet historyApiIsPatched: boolean = false;\n\n// We patch the history API so single-spa is notified of all calls to pushState/replaceState.\n// We patch addEventListener/removeEventListener so we can capture all popstate/hashchange event listeners,\n// and delay calling them until single-spa has finished mounting/unmounting applications\nexport function patchHistoryApi(opts?: StartOpts) {\n  if (historyApiIsPatched) {\n    throw Error(\n      formatErrorMessage(\n        43,\n        __DEV__ &&\n          `single-spa: patchHistoryApi() was called after the history api was already patched.`,\n      ),\n    );\n  }\n\n  // True by default, as a performance optimization that reduces\n  // the number of extraneous popstate events\n  urlRerouteOnly = opts?.hasOwnProperty(\"urlRerouteOnly\")\n    ? opts.urlRerouteOnly\n    : true;\n\n  historyApiIsPatched = true;\n\n  originalReplaceState = window.history.replaceState;\n\n  // We will trigger an app change for any routing events.\n  window.addEventListener(\"hashchange\", urlReroute);\n  window.addEventListener(\"popstate\", urlReroute);\n\n  // Patch addEventListener so that we can ensure correct timing\n  const originalAddEventListener = window.addEventListener;\n  const originalRemoveEventListener = window.removeEventListener;\n  window.addEventListener = function (eventName, fn) {\n    if (typeof fn === \"function\") {\n      if (\n        routingEventsListeningTo.indexOf(eventName) >= 0 &&\n        !capturedEventListeners[eventName].find((listener) => listener === fn)\n      ) {\n        capturedEventListeners[eventName].push(fn);\n        return;\n      }\n    }\n\n    return originalAddEventListener.apply(this, arguments);\n  };\n\n  window.removeEventListener = function (eventName, listenerFn) {\n    if (typeof listenerFn === \"function\") {\n      if (routingEventsListeningTo.includes(eventName)) {\n        capturedEventListeners[eventName] = capturedEventListeners[\n          eventName\n        ].filter((fn) => fn !== listenerFn);\n      }\n    }\n\n    return originalRemoveEventListener.apply(this, arguments);\n  };\n\n  window.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    \"pushState\",\n  );\n  window.history.replaceState = patchedUpdateState(\n    originalReplaceState,\n    \"replaceState\",\n  );\n}\n\n// Detect if single-spa has already been loaded on the page.\n// If so, warn because this can result in lots of problems, including\n// lots of extraneous popstate events and unexpected results for\n// apis like getAppNames().\nif (isInBrowser) {\n  if (window.singleSpaNavigate) {\n    console.warn(\n      formatErrorMessage(\n        41,\n        __DEV__ &&\n          \"single-spa has been loaded twice on the page. This can result in unexpected behavior.\",\n      ),\n    );\n  } else {\n    /* For convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag's href is.\n     */\n    window.singleSpaNavigate = navigateToUrl;\n  }\n}\n","import { routingEventsListeningTo } from \"./navigation/navigation-events\";\n\nlet hasInitialized: boolean = false;\n\nexport function ensureJQuerySupport(jQuery: any = window.jQuery): void {\n  if (!jQuery && window?.$?.fn?.jquery) {\n    jQuery = window.$;\n  }\n\n  if (jQuery && !hasInitialized) {\n    const originalJQueryOn = jQuery.fn.on;\n    const originalJQueryOff = jQuery.fn.off;\n\n    jQuery.fn.on = function (eventString, fn) {\n      return captureRoutingEvents.call(\n        this,\n        originalJQueryOn,\n        window.addEventListener,\n        eventString,\n        fn,\n        arguments,\n      );\n    };\n\n    jQuery.fn.off = function (eventString, fn) {\n      return captureRoutingEvents.call(\n        this,\n        originalJQueryOff,\n        window.removeEventListener,\n        eventString,\n        fn,\n        arguments,\n      );\n    };\n\n    hasInitialized = true;\n  }\n}\n\nfunction captureRoutingEvents(\n  originalJQueryFunction: Function,\n  nativeFunctionToCall: Function,\n  eventString: string,\n  fn: Function,\n  originalArgs: any[],\n) {\n  if (typeof eventString !== \"string\") {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n\n  const eventNames = eventString.split(/\\s+/);\n  eventNames.forEach((eventName) => {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n      nativeFunctionToCall(eventName, fn);\n      eventString = eventString.replace(eventName, \"\");\n    }\n  });\n\n  if (eventString.trim() === \"\") {\n    return this;\n  } else {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n}\n\ndeclare global {\n  interface Window {\n    jQuery?: any;\n    $?: any;\n  }\n}\n","import {\n  toName,\n  AppOrParcelStatus,\n  InternalApplication,\n} from \"../applications/app.helpers\";\nimport { handleAppError } from \"../applications/app-errors\";\nimport { reasonableTime } from \"../applications/timeouts\";\nimport { addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedApp } from \"./lifecycle.helpers\";\n\ninterface UnloadInfo {\n  app: InternalApplication;\n  promise?: Promise<any>;\n  resolve: (val?) => void;\n  reject: (val?) => void;\n}\n\nconst appsToUnload: Record<string, UnloadInfo> = {};\n\nexport function toUnloadPromise(app: LoadedApp): Promise<LoadedApp> {\n  return Promise.resolve().then(() => {\n    const unloadInfo = appsToUnload[toName(app)];\n\n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n       */\n      return app;\n    }\n\n    if (app.status === AppOrParcelStatus.NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(app, unloadInfo);\n      return app;\n    }\n\n    if (app.status === AppOrParcelStatus.UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      return unloadInfo.promise!.then(() => app);\n    }\n\n    if (\n      app.status !== AppOrParcelStatus.NOT_MOUNTED &&\n      app.status !== AppOrParcelStatus.LOAD_ERROR &&\n      app.status !== AppOrParcelStatus.SKIP_BECAUSE_BROKEN\n    ) {\n      /* The app cannot be unloaded unless in certain statuses\n       */\n      return app;\n    }\n\n    let startTime: number;\n\n    if (__PROFILE__) {\n      startTime = performance.now();\n    }\n\n    const unloadPromise = app.unload\n      ? reasonableTime(app, \"unload\")\n      : Promise.resolve();\n\n    app.status = AppOrParcelStatus.UNLOADING;\n\n    return unloadPromise\n      .then(() => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            \"application\",\n            toName(app),\n            \"unload\",\n            startTime,\n            performance.now(),\n            true,\n          );\n        }\n\n        finishUnloadingApp(app, unloadInfo);\n\n        return app;\n      })\n      .catch((err) => {\n        if (__PROFILE__) {\n          addProfileEntry(\n            \"application\",\n            toName(app),\n            \"unload\",\n            startTime,\n            performance.now(),\n            false,\n          );\n        }\n\n        errorUnloadingApp(app, unloadInfo, err);\n\n        return app;\n      });\n  });\n}\n\nfunction finishUnloadingApp(app: LoadedApp, unloadInfo: UnloadInfo) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don't have lifecycles\n  delete app.init;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  app.status = AppOrParcelStatus.NOT_LOADED;\n\n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app: LoadedApp, unloadInfo: UnloadInfo, err: Error) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don't have lifecycles\n  delete app.init;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleAppError(err, app, AppOrParcelStatus.SKIP_BECAUSE_BROKEN);\n  unloadInfo.reject(err);\n}\n\nexport function addAppToUnload(\n  app: InternalApplication,\n  promiseGetter: () => Promise<any>,\n  resolve: (val?) => any,\n  reject: (val?) => any,\n) {\n  appsToUnload[toName(app)] = { app, resolve, reject };\n  Object.defineProperty(appsToUnload[toName(app)], \"promise\", {\n    get: promiseGetter,\n  });\n}\n\nexport function getAppUnloadInfo(appName: string): UnloadInfo {\n  return appsToUnload[appName];\n}\n","import { ensureJQuerySupport } from \"../jquery-support\";\nimport {\n  isActive,\n  toName,\n  shouldBeActive,\n  InternalApplication,\n  AppOrParcelStatus,\n} from \"./app.helpers\";\nimport { reroute, triggerAppChange } from \"../navigation/reroute\";\nimport { toUnmountPromise } from \"../lifecycles/unmount\";\nimport {\n  toUnloadPromise,\n  getAppUnloadInfo,\n  addAppToUnload,\n} from \"../lifecycles/unload\";\nimport { formatErrorMessage } from \"./app-errors\";\nimport { isInBrowser } from \"../utils/runtime-environment\";\nimport { isStarted } from \"../start\";\nimport {\n  Activity,\n  ActivityFn,\n  AppProps,\n  Application,\n  CustomProps,\n  CustomPropsFn,\n  LifeCycles,\n  LoadApp,\n  LoadedApp,\n  RegisterApplicationConfig,\n  SingleSpaLocation,\n} from \"../lifecycles/lifecycle.helpers\";\n\nconst apps: InternalApplication[] = [];\n\ninterface AppChanges {\n  appsToUnload: InternalApplication[];\n  appsToUnmount: InternalApplication[];\n  appsToLoad: InternalApplication[];\n  appsToMount: InternalApplication[];\n}\n\nexport function getAppChanges(): AppChanges {\n  const appsToUnload: InternalApplication[] = [],\n    appsToUnmount: InternalApplication[] = [],\n    appsToLoad: InternalApplication[] = [],\n    appsToMount: InternalApplication[] = [];\n\n  // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds\n  const currentTime: number = new Date().getTime();\n\n  apps.forEach((app) => {\n    const appShouldBeActive =\n      app.status !== AppOrParcelStatus.SKIP_BECAUSE_BROKEN &&\n      shouldBeActive(app);\n\n    switch (app.status) {\n      case AppOrParcelStatus.LOAD_ERROR:\n        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n          appsToLoad.push(app);\n        }\n        break;\n      case AppOrParcelStatus.NOT_LOADED:\n      case AppOrParcelStatus.LOADING_SOURCE_CODE:\n        if (appShouldBeActive) {\n          appsToLoad.push(app);\n        }\n        break;\n      case AppOrParcelStatus.NOT_INITIALIZED:\n      case AppOrParcelStatus.NOT_MOUNTED:\n        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n          appsToUnload.push(app);\n        } else if (appShouldBeActive) {\n          appsToMount.push(app);\n        }\n        break;\n      case AppOrParcelStatus.MOUNTED:\n        if (!appShouldBeActive) {\n          appsToUnmount.push(app);\n        }\n        break;\n      // all other statuses are ignored\n    }\n  });\n\n  return { appsToUnload, appsToUnmount, appsToLoad, appsToMount };\n}\n\nexport function getMountedApps(): string[] {\n  return apps.filter(isActive).map(toName);\n}\n\nexport function getAppNames(): string[] {\n  return apps.map(toName);\n}\n\n// used in devtools, not (currently) exposed as a single-spa API\nexport function getRawAppData(): InternalApplication[] {\n  return [...apps];\n}\n\nexport function getAppStatus(appName): AppOrParcelStatus | null {\n  const app = apps.find((app) => toName(app) === appName);\n  return app ? app.status : null;\n}\n\nlet startWarningInitialized: boolean = false;\n\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n  RegisterApplicationConfig,\n): void;\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n  appName: string,\n  app: Application,\n  activeWhen: Activity,\n  customProps: ExtraProps | CustomPropsFn<ExtraProps>,\n): void;\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n  appNameOrConfig: string | RegisterApplicationConfig,\n  appOrLoadApp?: Application,\n  activeWhen?: Activity,\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>,\n): void {\n  const registration = sanitizeArguments(\n    appNameOrConfig,\n    appOrLoadApp,\n    activeWhen,\n    customProps,\n  );\n\n  if (!isStarted() && !startWarningInitialized) {\n    startWarningInitialized = true;\n\n    setTimeout(() => {\n      if (!isStarted()) {\n        console.warn(\n          formatErrorMessage(\n            1,\n            __DEV__ &&\n              `singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not initialized or mounted.`,\n          ),\n        );\n      }\n    }, 5000);\n  }\n\n  if (getAppNames().indexOf(registration.name) !== -1)\n    throw Error(\n      formatErrorMessage(\n        21,\n        __DEV__ &&\n          `There is already an app registered with name ${registration.name}`,\n        registration.name,\n      ),\n    );\n\n  apps.push(\n    Object.assign(\n      {\n        loadErrorTime: null,\n        status: AppOrParcelStatus.NOT_LOADED,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      registration,\n    ),\n  );\n\n  if (isInBrowser) {\n    ensureJQuerySupport();\n    reroute();\n  }\n}\n\nexport function checkActivityFunctions(\n  location: SingleSpaLocation = window.location,\n): string[] {\n  return apps.filter((app) => app.activeWhen(location)).map(toName);\n}\n\nexport function unregisterApplication(appName: string): Promise<void> {\n  if (apps.filter((app) => toName(app) === appName).length === 0) {\n    throw Error(\n      formatErrorMessage(\n        25,\n        __DEV__ &&\n          `Cannot unregister application '${appName}' because no such application has been registered`,\n        appName,\n      ),\n    );\n  }\n\n  const unloadPromise = isInBrowser\n    ? // See https://github.com/single-spa/single-spa/issues/871 for why waitForUnmount is false\n      unloadApplication(appName, { waitForUnmount: false })\n    : Promise.resolve();\n\n  return unloadPromise.then(() => {\n    const appIndex = apps.map(toName).indexOf(appName);\n    apps.splice(appIndex, 1);\n  });\n}\n\nexport function unloadApplication(\n  appName: string,\n  opts: { waitForUnmount: boolean } = { waitForUnmount: false },\n): Promise<void> {\n  if (typeof appName !== \"string\") {\n    throw Error(\n      formatErrorMessage(\n        26,\n        __DEV__ && `unloadApplication requires a string 'appName'`,\n      ),\n    );\n  }\n  const app = apps.find((app) => toName(app) === appName);\n  if (!app) {\n    throw Error(\n      formatErrorMessage(\n        27,\n        __DEV__ &&\n          `Could not unload application '${appName}' because no such application has been registered`,\n        appName,\n      ),\n    );\n  }\n\n  const appUnloadInfo = getAppUnloadInfo(toName(app));\n  if (opts?.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      return appUnloadInfo.promise;\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      const promise = new Promise<void>((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.\n     */\n\n    let resultPromise;\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n\n    return resultPromise;\n  }\n}\n\nfunction immediatelyUnloadApp(\n  app: InternalApplication,\n  resolve: (value?: any) => void,\n  reject: (value?: any) => void,\n): void {\n  Promise.resolve()\n    .then(() => {\n      // Before unmounting the application, we first must wait for it to finish mounting\n      // Otherwise, the test for issue 871 in unregister-application.spec.js fails because\n      // the application isn't really unmounted.\n      if (\n        checkActivityFunctions().find((activeApp) => activeApp === toName(app))\n      ) {\n        return triggerAppChange();\n      }\n    })\n    .then(() => {\n      return toUnmountPromise(app as LoadedApp)\n        .then(toUnloadPromise)\n        .then(() => {\n          resolve();\n          setTimeout(() => {\n            // reroute, but the unload promise is done\n            reroute();\n          });\n        });\n    })\n    .catch(reject);\n}\n\nfunction validateRegisterWithArguments(\n  name: string,\n  appOrLoadApp: Application,\n  activeWhen: Activity,\n  customProps?: CustomProps | CustomPropsFn,\n): void {\n  if (typeof name !== \"string\" || name.length === 0)\n    throw Error(\n      formatErrorMessage(\n        20,\n        __DEV__ &&\n          `The 1st argument to registerApplication must be a non-empty string 'appName'`,\n      ),\n    );\n\n  if (!appOrLoadApp)\n    throw Error(\n      formatErrorMessage(\n        23,\n        __DEV__ &&\n          \"The 2nd argument to registerApplication must be an application or loading application function\",\n      ),\n    );\n\n  if (typeof activeWhen !== \"function\")\n    throw Error(\n      formatErrorMessage(\n        24,\n        __DEV__ &&\n          \"The 3rd argument to registerApplication must be an activeWhen function\",\n      ),\n    );\n\n  if (!validCustomProps(customProps))\n    throw Error(\n      formatErrorMessage(\n        22,\n        __DEV__ &&\n          \"The optional 4th argument is a customProps and must be an object\",\n      ),\n    );\n}\n\nexport function validateRegisterWithConfig(\n  config: Partial<RegisterApplicationConfig>,\n): void {\n  if (Array.isArray(config) || config === null)\n    throw Error(\n      formatErrorMessage(\n        39,\n        __DEV__ && \"Configuration object can't be an Array or null!\",\n      ),\n    );\n  const validKeys = [\"name\", \"app\", \"activeWhen\", \"customProps\"];\n  const invalidKeys = Object.keys(config).reduce(\n    (invalidKeys, prop) =>\n      validKeys.indexOf(prop) >= 0 ? invalidKeys : invalidKeys.concat(prop),\n    [],\n  );\n  if (invalidKeys.length !== 0)\n    throw Error(\n      formatErrorMessage(\n        38,\n        __DEV__ &&\n          `The configuration object accepts only: ${validKeys.join(\n            \", \",\n          )}. Invalid keys: ${invalidKeys.join(\", \")}.`,\n        validKeys.join(\", \"),\n        invalidKeys.join(\", \"),\n      ),\n    );\n  if (typeof config.name !== \"string\" || config.name.length === 0)\n    throw Error(\n      formatErrorMessage(\n        20,\n        __DEV__ &&\n          \"The config.name on registerApplication must be a non-empty string\",\n      ),\n    );\n  if (typeof config.app !== \"object\" && typeof config.app !== \"function\")\n    throw Error(\n      formatErrorMessage(\n        20,\n        __DEV__ &&\n          \"The config.app on registerApplication must be an application or a loading function\",\n      ),\n    );\n  const allowsStringAndFunction = (activeWhen) =>\n    typeof activeWhen === \"string\" || typeof activeWhen === \"function\";\n  if (\n    !allowsStringAndFunction(config.activeWhen) &&\n    !(\n      Array.isArray(config.activeWhen) &&\n      config.activeWhen.every(allowsStringAndFunction)\n    )\n  )\n    throw Error(\n      formatErrorMessage(\n        24,\n        __DEV__ &&\n          \"The config.activeWhen on registerApplication must be a string, function or an array with both\",\n      ),\n    );\n  if (!validCustomProps(config.customProps))\n    throw Error(\n      formatErrorMessage(\n        22,\n        __DEV__ && \"The optional config.customProps must be an object\",\n      ),\n    );\n}\n\nfunction validCustomProps(customProps: unknown): boolean {\n  return (\n    !customProps ||\n    typeof customProps === \"function\" ||\n    (typeof customProps === \"object\" &&\n      customProps !== null &&\n      !Array.isArray(customProps))\n  );\n}\n\ninterface ApplicationRegistration {\n  name: string;\n  loadApp: LoadApp;\n  activeWhen: ActivityFn;\n  customProps?: CustomProps;\n}\n\nfunction sanitizeArguments<ExtraProps extends CustomProps = {}>(\n  appNameOrConfig: string | RegisterApplicationConfig,\n  appOrLoadApp: Application,\n  activeWhen: Activity,\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>,\n): ApplicationRegistration {\n  const usingObjectAPI = typeof appNameOrConfig === \"object\";\n\n  let unsanitizedRegistration: {\n    name: string;\n    app: Application;\n    activeWhen: Activity;\n    customProps: CustomProps | CustomPropsFn<CustomProps>;\n  };\n\n  if (usingObjectAPI) {\n    validateRegisterWithConfig(appNameOrConfig);\n    unsanitizedRegistration = {\n      name: appNameOrConfig.name,\n      app: appNameOrConfig.app,\n      activeWhen: appNameOrConfig.activeWhen,\n      customProps: appNameOrConfig.customProps,\n    };\n  } else {\n    validateRegisterWithArguments(\n      appNameOrConfig,\n      appOrLoadApp,\n      activeWhen,\n      customProps,\n    );\n    unsanitizedRegistration = {\n      name: appNameOrConfig,\n      app: appOrLoadApp,\n      activeWhen,\n      customProps,\n    };\n  }\n\n  return {\n    name: unsanitizedRegistration.name,\n    loadApp: sanitizeLoadApp(unsanitizedRegistration.app),\n    customProps: sanitizeCustomProps(unsanitizedRegistration.customProps),\n    activeWhen: sanitizeActiveWhen(unsanitizedRegistration.activeWhen),\n  };\n}\n\nfunction sanitizeLoadApp<ExtraProps extends CustomProps = {}>(\n  loadApp: Application,\n): (config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>> {\n  if (typeof loadApp !== \"function\") {\n    return () => Promise.resolve(loadApp);\n  }\n\n  return loadApp;\n}\n\nfunction sanitizeCustomProps(customProps?: CustomProps): CustomProps {\n  return customProps ? customProps : {};\n}\n\nfunction sanitizeActiveWhen(activeWhen: Activity): ActivityFn {\n  const activeWhenArray: (ActivityFn | string)[] = Array.isArray(activeWhen)\n    ? activeWhen\n    : [activeWhen];\n  const activityFnArray: ActivityFn[] = activeWhenArray.map(\n    (activeWhenOrPath) =>\n      typeof activeWhenOrPath === \"function\"\n        ? activeWhenOrPath\n        : pathToActiveWhen(activeWhenOrPath, false),\n  );\n\n  return (location) =>\n    activityFnArray.some((activeWhen) => activeWhen(location));\n}\n\nexport function pathToActiveWhen(\n  path: string,\n  exactMatch?: boolean,\n): ActivityFn {\n  const regex = toDynamicPathValidatorRegex(path, exactMatch);\n\n  return (location: Location) => {\n    const route = location.href\n      .replace(location.origin, \"\")\n      .replace(location.search, \"\")\n      .split(\"?\")[0];\n    return regex.test(route);\n  };\n}\n\nfunction toDynamicPathValidatorRegex(path: string, exactMatch?: boolean) {\n  let lastIndex: number = 0,\n    inDynamic: boolean = false,\n    regexStr: string = \"^\";\n\n  if (path[0] !== \"/\") {\n    path = \"/\" + path;\n  }\n\n  for (let charIndex = 0; charIndex < path.length; charIndex++) {\n    const char = path[charIndex];\n    const startOfDynamic = !inDynamic && char === \":\";\n    const endOfDynamic = inDynamic && char === \"/\";\n    if (startOfDynamic || endOfDynamic) {\n      appendToRegex(charIndex);\n    }\n  }\n\n  appendToRegex(path.length);\n  return new RegExp(regexStr, \"i\");\n\n  function appendToRegex(index) {\n    const anyCharMaybeTrailingSlashRegex = \"[^/]+/?\";\n    const commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));\n\n    regexStr += inDynamic\n      ? anyCharMaybeTrailingSlashRegex\n      : commonStringSubPath;\n\n    if (index === path.length) {\n      if (inDynamic) {\n        if (exactMatch) {\n          // Ensure exact match paths that end in a dynamic portion don't match\n          // urls with characters after a slash after the dynamic portion.\n          regexStr += \"$\";\n        }\n      } else {\n        // For exact matches, expect no more characters. Otherwise, allow\n        // any characters.\n        const suffix = exactMatch ? \"\" : \".*\";\n\n        regexStr =\n          // use charAt instead as we could not use es6 method endsWith\n          regexStr.charAt(regexStr.length - 1) === \"/\"\n            ? `${regexStr}${suffix}$`\n            : `${regexStr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    inDynamic = !inDynamic;\n    lastIndex = index;\n  }\n\n  function escapeStrRegex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n  }\n}\n","import { isStarted } from \"../start\";\nimport { toLoadPromise } from \"../lifecycles/load\";\nimport { toInitPromise } from \"../lifecycles/init\";\nimport { toMountPromise } from \"../lifecycles/mount\";\nimport { toUnmountPromise } from \"../lifecycles/unmount\";\nimport {\n  getAppStatus,\n  getAppChanges,\n  getMountedApps,\n} from \"../applications/apps\";\nimport {\n  callCapturedEventListeners,\n  originalReplaceState,\n} from \"./navigation-events\";\nimport { toUnloadPromise } from \"../lifecycles/unload\";\nimport {\n  toName,\n  shouldBeActive,\n  AppOrParcelStatus,\n  InternalApplication,\n} from \"../applications/app.helpers\";\nimport { isInBrowser } from \"../utils/runtime-environment\";\nimport { formatErrorMessage } from \"../applications/app-errors\";\nimport { ProfileEntry, addProfileEntry } from \"../devtools/profiler\";\nimport { LoadedApp } from \"../lifecycles/lifecycle.helpers\";\n\ntype EventArguments = [HashChangeEvent | PopStateEvent];\n\ninterface WaitingPromises {\n  resolve(value: unknown): void;\n  reject(value: unknown): void;\n  eventArguments?: [HashChangeEvent | PopStateEvent];\n}\n\nlet appChangeUnderway: boolean = false,\n  promisesWaitingOnAppChange: WaitingPromises[] = [],\n  currentUrl = isInBrowser && window.location.href;\n\nexport function triggerAppChange() {\n  // Call reroute with no arguments, intentionally\n  return reroute();\n}\n\nexport function reroute(\n  pendingPromises: WaitingPromises[] = [],\n  eventArguments: EventArguments = undefined,\n  silentNavigation: boolean = false,\n): Promise<string[]> {\n  if (appChangeUnderway) {\n    return new Promise((resolve, reject) => {\n      promisesWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n\n  let startTime: number, profilerKind: ProfileEntry[\"kind\"];\n\n  if (__PROFILE__) {\n    startTime = performance.now();\n    if (silentNavigation) {\n      profilerKind = \"silentNavigation\";\n    } else if (eventArguments) {\n      profilerKind = \"browserNavigation\";\n    } else {\n      profilerKind = \"triggerAppChange\";\n    }\n  }\n\n  const { appsToUnload, appsToUnmount, appsToLoad, appsToMount } =\n    getAppChanges();\n  let appsThatChanged: InternalApplication[],\n    cancelPromises: Promise<unknown>[] = [],\n    oldUrl: string = currentUrl,\n    newUrl: string = (currentUrl = window.location.href);\n\n  if (isStarted()) {\n    appChangeUnderway = true;\n    appsThatChanged = appsToUnload.concat(\n      appsToLoad,\n      appsToUnmount,\n      appsToMount,\n    );\n    return performAppChanges();\n  } else {\n    appsThatChanged = appsToLoad;\n    return loadApps();\n  }\n\n  function cancelNavigation(val: boolean | Promise<boolean> = true) {\n    const promise: Promise<boolean> =\n      typeof (val as Promise<boolean>)?.then === \"function\"\n        ? (val as Promise<boolean>)\n        : Promise.resolve(val);\n    cancelPromises.push(\n      promise.catch((err) => {\n        console.warn(\n          Error(\n            formatErrorMessage(\n              42,\n              __DEV__ &&\n                `single-spa: A cancelNavigation promise rejected with the following value: ${err}`,\n            ),\n          ),\n        );\n        console.warn(err);\n\n        // Interpret a Promise rejection to mean that the navigation should not be canceled\n        return false;\n      }),\n    );\n  }\n\n  function loadApps(): Promise<string[]> {\n    return Promise.resolve().then(() => {\n      const loadPromises = appsToLoad.map(toLoadPromise);\n      let succeeded: boolean;\n\n      return (\n        Promise.all(loadPromises)\n          .then(callAllEventListeners)\n          // there are no mounted apps, before start() is called, so we always return []\n          .then(() => {\n            if (__PROFILE__) {\n              succeeded = true;\n            }\n\n            return [];\n          })\n          .catch((err) => {\n            if (__PROFILE__) {\n              succeeded = false;\n            }\n\n            callAllEventListeners();\n            throw err;\n          })\n          .finally(() => {\n            if (__PROFILE__) {\n              addProfileEntry(\n                \"routing\",\n                \"loadApps\",\n                profilerKind,\n                startTime,\n                performance.now(),\n                succeeded,\n              );\n            }\n          })\n      );\n    });\n  }\n\n  function performAppChanges(): Promise<string[]> {\n    return Promise.resolve().then(() => {\n      // https://github.com/single-spa/single-spa/issues/545\n      fireSingleSpaEvent(\n        appsThatChanged.length === 0\n          ? \"before-no-app-change\"\n          : \"before-app-change\",\n        getCustomEventDetail(true),\n      );\n\n      fireSingleSpaEvent(\n        \"before-routing-event\",\n        getCustomEventDetail(true, { cancelNavigation }),\n      );\n\n      return Promise.all(cancelPromises).then((cancelValues) => {\n        const navigationIsCanceled: boolean = cancelValues.some((v) => v);\n\n        if (navigationIsCanceled) {\n          // Change url back to old url, without triggering the normal single-spa reroute\n          originalReplaceState.call(\n            window.history,\n            history.state,\n            \"\",\n            oldUrl.substring(location.origin.length),\n          );\n\n          // Single-spa's internal tracking of current url needs to be updated after the url change above\n          currentUrl = location.href;\n\n          // necessary for the reroute function to know that the current reroute is finished\n          appChangeUnderway = false;\n\n          if (__PROFILE__) {\n            addProfileEntry(\n              \"routing\",\n              \"navigationCanceled\",\n              profilerKind,\n              startTime,\n              performance.now(),\n              true,\n            );\n          }\n\n          // Tell single-spa to reroute again, this time with the url set to the old URL\n          return reroute(pendingPromises, eventArguments, true);\n        }\n\n        const unloadPromises: Promise<InternalApplication>[] =\n          appsToUnload.map(toUnloadPromise);\n\n        const unmountUnloadPromises = (appsToUnmount as LoadedApp[])\n          .map((app) => toUnmountPromise(app))\n          .map((unmountPromise: Promise<LoadedApp>) =>\n            unmountPromise.then(toUnloadPromise),\n          );\n\n        const allUnmountPromises: Promise<InternalApplication>[] = [\n          ...unmountUnloadPromises,\n          ...unloadPromises,\n        ];\n\n        const unmountAllPromise = Promise.all(allUnmountPromises);\n\n        let unmountFinishedTime: number;\n\n        unmountAllPromise.then(\n          () => {\n            if (__PROFILE__) {\n              unmountFinishedTime = performance.now();\n\n              addProfileEntry(\n                \"routing\",\n                \"unmountAndUnload\",\n                profilerKind,\n                startTime,\n                performance.now(),\n                true,\n              );\n            }\n            fireSingleSpaEvent(\n              \"before-mount-routing-event\",\n              getCustomEventDetail(true),\n            );\n          },\n          (err) => {\n            if (__PROFILE__) {\n              addProfileEntry(\n                \"routing\",\n                \"unmountAndUnload\",\n                profilerKind,\n                startTime,\n                performance.now(),\n                true,\n              );\n            }\n\n            throw err;\n          },\n        );\n\n        /* We load and init apps while other apps are unmounting, but we\n         * wait to mount the app until all apps are finishing unmounting\n         */\n        const loadThenMountPromises: Promise<InternalApplication>[] =\n          appsToLoad.map((app) => {\n            return toLoadPromise(app).then((app) =>\n              tryToInitAndMount(app, unmountAllPromise),\n            );\n          });\n\n        /* These are the apps that are already initialized and just need\n         * to be mounted. They each wait for all unmounting apps to finish up\n         * before they mount.\n         */\n        const mountPromises: Promise<InternalApplication>[] = appsToMount\n          .filter((appToMount) => !appsToLoad.includes(appToMount))\n          .map((appToMount) => {\n            return tryToInitAndMount(appToMount, unmountAllPromise);\n          });\n        return unmountAllPromise\n          .catch((err) => {\n            callAllEventListeners();\n            throw err;\n          })\n          .then(() => {\n            /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n             * events (like hashchange or popstate) should have been cleaned up. So it's safe\n             * to let the remaining captured event listeners to handle about the DOM event.\n             */\n            callAllEventListeners();\n\n            return Promise.all(loadThenMountPromises.concat(mountPromises))\n              .catch((err) => {\n                pendingPromises.forEach((promise) => promise.reject(err));\n                throw err;\n              })\n              .then(\n                () => {\n                  if (__PROFILE__) {\n                    addProfileEntry(\n                      \"routing\",\n                      \"loadAndMount\",\n                      profilerKind,\n                      unmountFinishedTime,\n                      performance.now(),\n                      true,\n                    );\n                  }\n                },\n                (err) => {\n                  if (__PROFILE__) {\n                    addProfileEntry(\n                      \"routing\",\n                      \"loadAndMount\",\n                      profilerKind,\n                      unmountFinishedTime,\n                      performance.now(),\n                      false,\n                    );\n                  }\n\n                  throw err;\n                },\n              )\n              .then(finishUpAndReturn);\n          });\n      });\n    });\n  }\n\n  function finishUpAndReturn(): string[] {\n    const returnValue = getMountedApps();\n    pendingPromises.forEach((promise) => promise.resolve(returnValue));\n\n    try {\n      const appChangeEventName =\n        appsThatChanged.length === 0 ? \"no-app-change\" : \"app-change\";\n      fireSingleSpaEvent(appChangeEventName, getCustomEventDetail());\n      fireSingleSpaEvent(\"routing-event\", getCustomEventDetail());\n    } catch (err) {\n      /* We use a setTimeout because if someone else's event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it's their own fault, not\n       * single-spa's.\n       */\n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    appChangeUnderway = false;\n\n    if (promisesWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      const nextPendingPromises = promisesWaitingOnAppChange;\n      promisesWaitingOnAppChange = [];\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n\n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  function callAllEventListeners() {\n    // During silent navigation (when navigation was canceled and we're going back to the old URL),\n    // we should not fire any popstate / hashchange events\n    if (!silentNavigation) {\n      pendingPromises.forEach((pendingPromise) => {\n        callCapturedEventListeners(pendingPromise.eventArguments);\n      });\n\n      callCapturedEventListeners(eventArguments);\n    }\n  }\n\n  function getCustomEventDetail(\n    isBeforeChanges: boolean = false,\n    extraProperties?: Object,\n  ): CustomEventInit {\n    const newAppStatuses = {};\n    const appsByNewStatus = {\n      // for apps that were mounted\n      [AppOrParcelStatus.MOUNTED]: [],\n      // for apps that were unmounted\n      [AppOrParcelStatus.NOT_MOUNTED]: [],\n      // apps that were forcibly unloaded\n      [AppOrParcelStatus.NOT_LOADED]: [],\n      // apps that attempted to do something but are broken now\n      [AppOrParcelStatus.SKIP_BECAUSE_BROKEN]: [],\n    };\n\n    if (isBeforeChanges) {\n      appsToLoad.concat(appsToMount).forEach((app, index) => {\n        addApp(app, AppOrParcelStatus.MOUNTED);\n      });\n      appsToUnload.forEach((app) => {\n        addApp(app, AppOrParcelStatus.NOT_LOADED);\n      });\n      appsToUnmount.forEach((app) => {\n        addApp(app, AppOrParcelStatus.NOT_MOUNTED);\n      });\n    } else {\n      appsThatChanged.forEach((app) => {\n        addApp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newAppStatuses,\n        appsByNewStatus,\n        totalAppChanges: appsThatChanged.length,\n        originalEvent: eventArguments?.[0],\n        oldUrl,\n        newUrl,\n      },\n    };\n\n    if (extraProperties) {\n      Object.assign(result.detail, extraProperties);\n    }\n\n    return result;\n\n    function addApp(\n      app: InternalApplication,\n      status?: InternalApplication[\"status\"],\n    ) {\n      const appName = toName(app);\n      status = status || getAppStatus(appName);\n      newAppStatuses[appName] = status;\n      const statusArr = (appsByNewStatus[status] =\n        appsByNewStatus[status] || []);\n      statusArr.push(appName);\n    }\n  }\n\n  function fireSingleSpaEvent(name: string, eventProperties: CustomEventInit) {\n    // During silent navigation (caused by navigation cancelation), we should not\n    // fire any single-spa events\n    if (!silentNavigation) {\n      window.dispatchEvent(\n        new CustomEvent(`single-spa:${name}`, eventProperties),\n      );\n    }\n  }\n}\n\n/**\n * Let's imagine that some kind of delay occurred during application loading.\n * The user without waiting for the application to load switched to another route,\n * this means that we shouldn't initialize and mount that application, thus we check\n * twice if that application should be active before initialize and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */\nfunction tryToInitAndMount(\n  app: InternalApplication,\n  unmountAllPromise: Promise<unknown>,\n): Promise<InternalApplication> {\n  if (shouldBeActive(app)) {\n    return toInitPromise(app as LoadedApp).then((app) =>\n      unmountAllPromise.then(() =>\n        shouldBeActive(app) ? toMountPromise(app) : app,\n      ),\n    ) as Promise<InternalApplication>;\n  } else {\n    return unmountAllPromise.then(() => app);\n  }\n}\n","import { reroute } from \"./navigation/reroute\";\nimport { patchHistoryApi } from \"./navigation/navigation-events\";\nimport { isInBrowser } from \"./utils/runtime-environment\";\n\nlet started: boolean = false;\n\nexport function start(opts?: StartOpts) {\n  started = true;\n  if (isInBrowser) {\n    patchHistoryApi(opts);\n    reroute();\n  }\n}\n\nexport function isStarted(): boolean {\n  return started;\n}\n\nexport interface StartOpts {\n  urlRerouteOnly?: boolean;\n}\n","import { getRawAppData, unregisterApplication } from \"../applications/apps\";\nimport { reroute } from \"../navigation/reroute\";\nimport { AppOrParcelStatus } from \"../applications/app.helpers\";\nimport { toLoadPromise } from \"../lifecycles/load\";\nimport { toInitPromise } from \"../lifecycles/init\";\nimport { getProfilerData } from \"./profiler\";\n\nexport default {\n  getRawAppData,\n  reroute,\n  NOT_LOADED: AppOrParcelStatus.NOT_LOADED,\n  toLoadPromise,\n  toBootstrapPromise: toInitPromise,\n  unregisterApplication,\n  getProfilerData,\n};\n","export { start } from \"./start\";\nexport type { StartOpts } from \"./start\";\nexport { ensureJQuerySupport } from \"./jquery-support\";\nexport {\n  setInitMaxTime,\n  setMountMaxTime,\n  setUnmountMaxTime,\n  setUnloadMaxTime,\n} from \"./applications/timeouts\";\nexport {\n  registerApplication,\n  unregisterApplication,\n  getMountedApps,\n  getAppStatus,\n  unloadApplication,\n  checkActivityFunctions,\n  getAppNames,\n  pathToActiveWhen,\n} from \"./applications/apps\";\nexport { navigateToUrl, patchHistoryApi } from \"./navigation/navigation-events\";\nexport { triggerAppChange } from \"./navigation/reroute\";\nexport {\n  addErrorHandler,\n  removeErrorHandler,\n  type SingleSpaError,\n  type ErrorHandler,\n} from \"./applications/app-errors\";\nexport { mountRootParcel } from \"./parcels/mount-parcel\";\nexport type {\n  CustomProps,\n  ParcelCustomProps,\n  CustomPropsFn,\n  AppProps,\n  ParcelConfig,\n  ParcelConfigObject,\n  LifeCycles,\n  LifeCycleFn,\n  Parcel,\n  Application,\n  LoadApp,\n  ActivityFn,\n  Activity,\n  RegisterApplicationConfig,\n} from \"./lifecycles/lifecycle.helpers\";\n\nexport { AppOrParcelStatus } from \"./applications/app.helpers\";\n\nimport devtools from \"./devtools/devtools\";\nimport { isInBrowser } from \"./utils/runtime-environment\";\n\nif (isInBrowser && window.__SINGLE_SPA_DEVTOOLS__) {\n  window.__SINGLE_SPA_DEVTOOLS__.exposedMethods = devtools;\n}\n\ndeclare global {\n  interface Window {\n    __SINGLE_SPA_DEVTOOLS__: {\n      exposedMethods: typeof devtools;\n    };\n  }\n}\n"],"names":["errorHandlers","handleAppError","err","app","newStatus","transformedErr","transformErr","length","forEach","handler","setTimeout","addErrorHandler","Error","formatErrorMessage","push","removeErrorHandler","removedSomething","filter","h","isHandler","code","msg","args","join","ogErr","appOrParcel","errPrefix","objectType","toName","status","result","message","console","warn","JSON","stringify","singleSpaErr","appOrParcelName","AppOrParcelStatus","isActive","MOUNTED","shouldBeActive","activeWhen","window","location","SKIP_BECAUSE_BROKEN","name","isParcel","Boolean","unmountThisParcel","validLifecycleFn","fn","isArrayOfFns","arr","Array","isArray","find","item","flattenFnArray","lifecycle","fns","Promise","resolve","type","props","reduce","resultPromise","index","then","thisPromise","smellsLikeAPromise","reject","promise","catch","profileEntries","getProfilerData","addProfileEntry","kind","start","end","operationSucceeded","toInitPromise","hardFail","startTime","profileEventType","NOT_INITIALIZED","performance","now","INITIALIZING","reasonableTime","successfulInit","NOT_MOUNTED","toUnmountPromise","UNMOUNTING","unmountChildrenParcels","Object","keys","parcels","map","parcelId","all","unmountAppOrParcel","parcelError","parentError","beforeFirstMountFired","firstMountFired","toMountPromise","dispatchEvent","CustomEvent","MOUNTING","setSkipBecauseBroken","toUpdatePromise","UPDATING","parcelCount","rootParcels","mountRootParcel","config","customProps","mountParcel","call","owningAppOrParcel","id","domElement","passedConfigLoadingFunction","configLoadingFunction","parcel","LOADING_SOURCE_CODE","parentName","currentTask","undefined","value","resolveUnmount","rejectUnmount","loadPromise","prototype","hasOwnProperty","init","mount","unmount","update","timeouts","ensureValidAppTimeouts","fullParcel","initPromise","mountPromise","unmountPromise","externalRepresentation","promiseWithoutReturnValue","getStatus","_parcel","getProps","assign","bind","unmountSelf","defaultWarningMillis","globalTimeoutConfig","millis","dieOnTimeout","warningMillis","unload","setInitMaxTime","time","setMountMaxTime","setUnmountMaxTime","setUnloadMaxTime","timeoutConfig","warningPeriod","finished","errored","val","maybeTimingOut","errMsg","shouldError","error","numWarnings","numMillis","key","_a","toLoadPromise","NOT_LOADED","LOAD_ERROR","appBeingLoaded","lifecycles","isUserErr","loadApp","loadErrorTime","validationErrMessage","validationErrCode","appOptsStr","devtools","overlays","Date","getTime","isInBrowser","capturedEventListeners","hashchange","popstate","routingEventsListeningTo","navigateToUrl","obj","url","href","currentTarget","preventDefault","current","URL","destination","indexOf","hash","host","pathname","search","history","pushState","callCapturedEventListeners","eventArguments","eventType","listener","apply","e","urlRerouteOnly","urlReroute","evt","reroute","patchedUpdateState","updateState","methodName","urlBefore","arguments","urlAfter","createPopStateEvent","state","originalMethodName","PopStateEvent","singleSpa","singleSpaTrigger","originalReplaceState","historyApiIsPatched","patchHistoryApi","opts","replaceState","addEventListener","originalAddEventListener","originalRemoveEventListener","removeEventListener","eventName","listenerFn","includes","singleSpaNavigate","hasInitialized","ensureJQuerySupport","jQuery","$","jquery","originalJQueryOn","on","originalJQueryOff","off","eventString","captureRoutingEvents","originalJQueryFunction","nativeFunctionToCall","originalArgs","eventNames","split","replace","trim","appsToUnload","toUnloadPromise","unloadInfo","finishUnloadingApp","UNLOADING","unloadPromise","errorUnloadingApp","addAppToUnload","promiseGetter","defineProperty","get","getAppUnloadInfo","appName","apps","getAppChanges","appsToUnmount","appsToLoad","appsToMount","currentTime","appShouldBeActive","getMountedApps","getAppNames","getRawAppData","getAppStatus","startWarningInitialized","registerApplication","appNameOrConfig","appOrLoadApp","registration","sanitizeArguments","isStarted","options","selectors","checkActivityFunctions","unregisterApplication","unloadApplication","waitForUnmount","appIndex","splice","appUnloadInfo","immediatelyUnloadApp","activeApp","triggerAppChange","validateRegisterWithArguments","validCustomProps","validateRegisterWithConfig","validKeys","invalidKeys","prop","concat","allowsStringAndFunction","every","usingObjectAPI","unsanitizedRegistration","sanitizeLoadApp","sanitizeCustomProps","sanitizeActiveWhen","activeWhenArray","activityFnArray","activeWhenOrPath","pathToActiveWhen","some","path","exactMatch","regex","toDynamicPathValidatorRegex","route","origin","test","lastIndex","inDynamic","regexStr","charIndex","char","startOfDynamic","endOfDynamic","appendToRegex","RegExp","anyCharMaybeTrailingSlashRegex","commonStringSubPath","escapeStrRegex","slice","suffix","charAt","str","appChangeUnderway","promisesWaitingOnAppChange","currentUrl","pendingPromises","silentNavigation","profilerKind","appsThatChanged","cancelPromises","oldUrl","newUrl","performAppChanges","loadApps","cancelNavigation","loadPromises","succeeded","callAllEventListeners","finally","fireSingleSpaEvent","getCustomEventDetail","cancelValues","navigationIsCanceled","v","substring","unloadPromises","unmountUnloadPromises","allUnmountPromises","unmountAllPromise","unmountFinishedTime","loadThenMountPromises","tryToInitAndMount","mountPromises","appToMount","finishUpAndReturn","returnValue","appChangeEventName","nextPendingPromises","pendingPromise","isBeforeChanges","extraProperties","newAppStatuses","appsByNewStatus","addApp","detail","totalAppChanges","originalEvent","statusArr","eventProperties","started","toBootstrapPromise","__SINGLE_SPA_DEVTOOLS__","exposedMethods"],"mappings":"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"}